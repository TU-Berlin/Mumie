package net.mumie.srv.notions;

/**
 * Static utilities for data entity types.
 *
 * <p>
 *   The term <em>data entity</em> comprises documents and pseudo-documents. Each data
 *   entity has a <em>type</em>. Data entity types are specified by numerical codes or,
 *   alternativly, by names. The computer almost only uses the numerical codes. The names
 *   exist to have a more human-readable data entity type specification as well.
 * </p>
 * <p>
 *   This class defines static constants with self-explanatory names wrapping the numerical
 *   codes, and some auxilliary constants and methods. 
 * </p>
 * <p>
 *   Parts of the Java source of this class are autogenerated in the build process.
 * </p>
 *
 * @author Tilman Rassy <a href="mailto:rassy@math.tu-berlin.de">rassy@math.tu-berlin.de</a>
 * @version <code>$Id: EntityType.java.skel,v 1.4 2009/04/24 23:53:12 rassy Exp $</code>
 */

public class EntityType
{
  // --------------------------------------------------------------------------------
  // Global variables and constants, except autocoded 
  // --------------------------------------------------------------------------------

  /**
   * The undefined data entity type.
   */

  public static final int UNDEFINED = -1;

  // --------------------------------------------------------------------------------
  // Auxiliaries 
  // --------------------------------------------------------------------------------

  /**
   * Returns the array index of the specified (pseudo-)document type code.
   */

  protected static final int indexOf (int code)
  {
    int index = -1;
    for (int i = 0; i < types.length && index == -1; i++)
      {
        if ( types[i] == code )
          index = i;
      }
    if ( index == -1 )
      throw new IllegalArgumentException("Invalid (pseudo-)document type code: " + code);
    return index;
  }

  /**
   * Returns the array index of the (pseudo-)document type with the specified name.
   */

  protected static final int indexOf (String name)
  {
    int index = -1;
    for (int i = 0; i < names.length && index == -1; i++)
      {
        if ( names[i].equals(name) )
          index = i;
      }
    if ( index == -1 )
      throw new IllegalArgumentException("Invalid (pseudo-)document type name: " + name);
    return index;
  }

  // --------------------------------------------------------------------------------
  // Getting codes for names and vice versa
  // --------------------------------------------------------------------------------

  /**
   * Returns the name for the (pseudo-)document type represented by the specified numerical
   * code.
   */

  public static final String nameFor (int code)
  {
    return names[indexOf(code)];
  }

  /**
   * Returns the numerical code for the specified (pseudo-)document type name.
   */

  public static final int codeFor (String name)
  {
    return types[indexOf(name)];
  }

  // --------------------------------------------------------------------------------
  // Getting selector hints
  // --------------------------------------------------------------------------------

  /**
   * Returns the selector hint for the (pseudo-)document type represented by the specified
   * code.
   */

  public static final String hintFor (int code)
  {
    return hints[indexOf(code)];
  }

  /**
   * Returns the selector hint for the (pseudo-)document type with the the specified name.
   */

  public static final String hintFor (String name)
  {
    return hints[indexOf(name)];
  }

  // --------------------------------------------------------------------------------
  // Checking whether a code or name exists as a (pseudo-)document type
  // --------------------------------------------------------------------------------

  /**
   * Returns true if the specified integer exists as a (pseudo-)document type code;
   * otherwise returns false.
   */

  public static final boolean exists (int code)
  {
    for (int i = 0; i < types.length; i++)
      {
        if ( types[i] == code )
          return true;
      }
    return false;
  }

  /**
   * Returns true if the specified string exists as a (pseudo-)document type name;
   * otherwise returns false.
   */

  public static final boolean exists (String name)
  {
    for (int i = 0; i < names.length; i++)
      {
        if ( names[i].equals(name) )
          return true;
      }
    return false;
  }

  // --------------------------------------------------------------------------------
  // Getting (pseudo-)document properties
  // --------------------------------------------------------------------------------

  /**
   * Returns the nature (document or pseudo-document) of the specified type.
   */

  public static final int natureOf (int code)
  {
    return natures[indexOf(code)];
  }

  /**
   * Returns the content format of the specified type.
   */

  public static final int contentFormatOf (int code)
  {
    return contentFormats[indexOf(code)];
  }

  /**
   * Returns the db table name of the specified type.
   */

  public static final String dbTableOf (int code)
  {
    return dbTables[indexOf(code)];
  }

  /**
   * Returns the "read" db table name of the specified type.
   */

  public static final String dbReadTableOf (int code)
  {
    return dbReadTables[indexOf(code)];
  }

  /**
   * Returns the name of the db reference table of the specified types.
   */

  public static final String dbRefTableOf(int originCode, int targetCode)
  {
    return dbRefTables[indexOf(originCode)][indexOf(targetCode)];
  }

  /**
   * Returns the name of the vc thread db table of the specified type.
   */

  public static final String dbVCThreadTableOf (int code)
  {
    return dbVCThreadTables[indexOf(code)];
  }

  /**
   * Returns the name of the GDIM db table of the specified type.
   */

  public static final String dbGDIMTableOf (int code)
  {
    return dbGDIMTables[indexOf(code)];
  }

  /**
   * Returns the name of the read permission db table of the specified type.
   */

  public static final String dbReadPermTableOf (int code)
  {
    return dbReadPermTables[indexOf(code)];
  }

  /**
   * Returns the name of the authors db table of the specified type.
   */

  public static final String dbAuthorTableOf (int code)
  {
    return dbAuthorTables[indexOf(code)];
  }

  /**
   * Returns the name of the write permission db table of the specified type.
   */

  public static final String dbWritePermTableOf (int code)
  {
    return dbWritePermTables[indexOf(code)];
  }

  /**
   * Returns the XML element name of the specified type.
   */

  public static final String xmlElementOf (int code)
  {
    return xmlElements[indexOf(code)];
  }

  /**
   * Returns whether the specified type is a generic document type or not.
   */

  public static final boolean isGeneric (int code)
  {
    return isGeneric[indexOf(code)];
  }

  /**
   * Returns whether the specified type is a document type which has a generic counterpart.
   */

  public static final boolean hasGeneric (int code)
  {
    return hasGeneric[indexOf(code)];
  }

  /**
   * Returns the type of the generic counterpart of the specified type, or
   * {@link #UNDEFINED UNDEFINED} if the type has no generic counterpart.
   */

  public static final int genericOf (int code)
  {
    return genericOf[indexOf(code)];
  }

  /**
   * Returns the type of the real counterpart of the specified type, or
   * {@link #UNDEFINED UNDEFINED} if the type has no real counterpart.
   */

  public static final int realOf (int code)
  {
    return realOf[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a category.
   */

  public static final boolean hasCategory (int code)
  {
    return hasCategory[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a corrector.
   */

  public static final boolean hasCorrector (int code)
  {
    return hasCorrector[indexOf(code)];
  }

  /**
   * Returns whether the specified type has width and height.
   */

  public static final boolean hasWidthAndHeight (int code)
  {
    return hasWidthAndHeight[indexOf(code)];
  }

  /**
   * Returns whether the specified type has members.
   */

  public static final boolean hasMembers (int code)
  {
    return hasMembers[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a timeframe.
   */

  public static final boolean hasTimeframe (int code)
  {
    return hasTimeframe[indexOf(code)];
  }

  /**
   * Provides the information which references have labels.
   * If <code>refsHaveLabels</code>(<var>originCode</var>, <var>targetCode</var>) returns true,
   * references from documents of type <var>originCode</var> to those of type
   * <var>targetCode</var> have labels, otherwise they have not.
   * The method acceps pseudo-documents for <var>originCode</var> and/or <var>targetCode</var>,
   * too, but returns false in all that cases.
   *
   * @param originCode numerical code of the type of the reference origin
   * @param targetCode numerical code of the type of the reference target
   *
   * @returns true if the corresponding references have labels, otherwise false.
   */

  public static final boolean refsHaveLabels (int originCode, int targetCode)
  {
    return refsHaveLabels[indexOf(originCode)][indexOf(targetCode)];
  }

  /**
   * Provides the information which references have points.
   * If <code>refsHavePoints</code>(<var>originCode</var>, <var>targetCode</var>) returns true,
   * references from documents of type <var>originCode</var> to those of type
   * <var>targetCode</var> have points, otherwise they have not.
   * The method acceps pseudo-documents for <var>originCode</var> and/or <var>targetCode</var>,
   * too, but returns false in all that cases.
   *
   * @param originCode numerical code of the type of the reference origin
   * @param targetCode numerical code of the type of the reference target
   *
   * @returns true if the corresponding references have points, otherwise false.
   */

  public static final boolean refsHavePoints (int originCode, int targetCode)
  {
    return refsHavePoints[indexOf(originCode)][indexOf(targetCode)];
  }

  // --------------------------------------------------------------------------------
  // Getting all or subsets of types
  // --------------------------------------------------------------------------------

  /**
   * Returns an array containing all (pseudo-)document types. The array is is not backed by
   * any variables of this class, so changes to the array do not effect this class.
   */

  public static final int[] allTypes ()
  {
    int[] typesCopy = new int[types.length];
    System.arraycopy(types, 0, typesCopy, 0, types.length);
    return typesCopy;
  }

  /**
   * Returns an array containing all document types (but not the pseudo-document types). The
   * array is is not backed by any variables of this class, so changes to the array do not
   * effect this class.
   */

  public static final int[] docTypes ()
  {
    int[] docTypesCopy = new int[docTypes.length];
    System.arraycopy(docTypes, 0, docTypesCopy, 0, docTypes.length);
    return docTypesCopy;
  }

  /**
   * Returns an array containing all pseudo-document types (but not the document types). The
   * array is is not backed by any variables of this class, so changes to the array do not
   * effect this class.
   */

  public static final int[] pseudoDocTypes ()
  {
    int[] pseudoDocTypesCopy = new int[pseudoDocTypes.length];
    System.arraycopy(pseudoDocTypes, 0, pseudoDocTypesCopy, 0, pseudoDocTypes.length);
    return pseudoDocTypesCopy;
  }

  // ================================================================================
  // Autocoded methods start
  // ================================================================================

  //#AUTOCODED

  // ================================================================================
  // Autocoded methods end
  // ================================================================================

  /**
   * Disabled constructor.
   */

  private EntityType ()
    throws IllegalAccessException
  {
    throw new IllegalAccessException("EntityType must not be instanciated");
  }
}
