// -*- jde -*-

package net.mumie.cocoon.notions;

/**
 * Static utilities for data entity types.
 *
 * <p>
 *   The term <em>data entity</em> comprises documents and pseudo-documents. Each data
 *   entity has a <em>type</em>. Data entity types are specified by numerical codes or,
 *   alternativly, by names. The computer almost only uses the numerical codes. The names
 *   exist to have a more human-readable data entity type specification as well.
 * </p>
 * <p>
 *   This class defines static constants with self-explanatory names wrapping the numerical
 *   codes, and some auxilliary constants and methods. 
 * </p>
 * <p>
 *   Parts of the Java source of this class are autogenerated in the build process.
 * </p>
 *
 * @author Tilman Rassy <a href="mailto:rassy@math.tu-berlin.de">rassy@math.tu-berlin.de</a>
 * @version <code>$Id: DataEntityType.java.skel,v 1.2 2008/01/24 16:29:22 rassy Exp $</code>
 */

public class DataEntityType
{
  // --------------------------------------------------------------------------------
  // Global variabled and constants, except autocoded 
  // --------------------------------------------------------------------------------

  /**
   * The undefined data entity type.
   */

  public static final int UNDEFINED = -1;

  // --------------------------------------------------------------------------------
  // Auxiliaries 
  // --------------------------------------------------------------------------------

  /**
   * Returns the array index of the specified (pseudo-)document type code.
   */

  protected static final int indexOf (int code)
  {
    int index = -1;
    for (int i = 0; i < types.length && index == -1; i++)
      {
        if ( types[i] == code )
          index = i;
      }
    if ( index == -1 )
      throw new IllegalArgumentException("Invalid (pseudo-)document type code: " + code);
    return index;
  }

  /**
   * Returns the array index of the (pseudo-)document type with the specified name.
   */

  protected static final int indexOf (String name)
  {
    int index = -1;
    for (int i = 0; i < names.length && index == -1; i++)
      {
        if ( names[i].equals(name) )
          index = i;
      }
    if ( index == -1 )
      throw new IllegalArgumentException("Invalid (pseudo-)document type name: " + name);
    return index;
  }

  // --------------------------------------------------------------------------------
  // Getting codes for names and vice versa
  // --------------------------------------------------------------------------------

  /**
   * Returns the name for the (pseudo-)document type represented by the specified numerical
   * code.
   */

  public static final String nameFor (int code)
  {
    return names[indexOf(code)];
  }

  /**
   * Returns the numerical code for the specified (pseudo-)document type name.
   */

  public static final int codeFor (String name)
  {
    return types[indexOf(name)];
  }

  // --------------------------------------------------------------------------------
  // Getting selector hints
  // --------------------------------------------------------------------------------

  /**
   * Returns the selector hint for the (pseudo-)document type represented by the specified
   * code.
   */

  public static final String hintFor (int code)
  {
    return hints[indexOf(code)];
  }

  /**
   * Returns the selector hint for the (pseudo-)document type with the the specified name.
   */

  public static final String hintFor (String name)
  {
    return hints[indexOf(name)];
  }

  // --------------------------------------------------------------------------------
  // Checking whether a code or name exists as a (pseudo-)document type
  // --------------------------------------------------------------------------------

  /**
   * Returns true if the specified integer exists as a (pseudo-)document type code;
   * otherwise returns false.
   */

  public static final boolean exists (int code)
  {
    for (int i = 0; i < types.length; i++)
      {
        if ( types[i] == code )
          return true;
      }
    return false;
  }

  /**
   * Returns true if the specified string exists as a (pseudo-)document type name;
   * otherwise returns false.
   */

  public static final boolean exists (String name)
  {
    for (int i = 0; i < names.length; i++)
      {
        if ( names[i].equals(name) )
          return true;
      }
    return false;
  }

  // --------------------------------------------------------------------------------
  // Getting (pseudo-)document properties
  // --------------------------------------------------------------------------------

  /**
   * Returns the nature (document or pseudo-document) of the specified type.
   */

  public static final int natureOf (int code)
  {
    return natures[indexOf(code)];
  }

  /**
   * Returns the db table name of the specified type.
   */

  public static final String dbTableOf (int code)
  {
    return dbTables[indexOf(code)];
  }

  /**
   * Returns the name of the db reference table of the specified types.
   */

  public static final String dbRefTableOf(int originCode, int targetCode)
  {
    return dbRefTables[indexOf(originCode)][indexOf(targetCode)];
  }

  /**
   * Returns whether the specified type is a generic document type ot not.
   */

  public static final boolean isGeneric (int code)
  {
    return isGeneric[indexOf(code)];
  }

  /**
   * Returns whether the specified type is a document type which has a generic counterpart.
   */

  public static final boolean hasGeneric (int code)
  {
    return hasGeneric[indexOf(code)];
  }

  /**
   * Returns the type of the generic counterpart of the specified type, or
   * {@link #UNDEFINED UNDEFINED} if the type has no generic counterpart.
   */

  public static final int genericOf (int code)
  {
    return genericOf[indexOf(code)];
  }

  /**
   * Returns the type of the real counterpart of the specified type, or
   * {@link #UNDEFINED UNDEFINED} if the type has no real counterpart.
   */

  public static final int realOf (int code)
  {
    return realOf[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a category.
   */

  public static final boolean hasCategory (int code)
  {
    return hasCategory[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a corrector.
   */

  public static final boolean hasCorrector (int code)
  {
    return hasCorrector[indexOf(code)];
  }

  /**
   * Returns whether the specified type has width and height.
   */

  public static final boolean hasWidthAndHeight (int code)
  {
    return hasWidthAndHeight[indexOf(code)];
  }

  /**
   * Returns whether the specified type has members.
   */

  public static final boolean hasMembers (int code)
  {
    return hasMembers[indexOf(code)];
  }

  /**
   * Returns whether the specified type has a timeframe.
   */

  public static final boolean hasTimeframe (int code)
  {
    return hasTimeframe[indexOf(code)];
  }

  // --------------------------------------------------------------------------------
  // Getting all or subsets of types
  // --------------------------------------------------------------------------------

  /**
   * Returns an array containing all (pseudo-)document types. The array is is not backed by
   * any variables of this class, so changes to the array do not effect this class.
   */

  public static final int[] allTypes ()
  {
    int[] typesCopy = new int[types.length];
    System.arraycopy(types, 0, typesCopy, 0, types.length);
    return typesCopy;
  }

  /**
   * Returns an array containing all document types (but not the pseudo-document types). The
   * array is is not backed by any variables of this class, so changes to the array do not
   * effect this class.
   */

  public static final int[] docTypes ()
  {
    int[] docTypesCopy = new int[docTypes.length];
    System.arraycopy(docTypes, 0, docTypesCopy, 0, docTypes.length);
    return docTypesCopy;
  }

  /**
   * Returns an array containing all pseudo-document types (but not the document types). The
   * array is is not backed by any variables of this class, so changes to the array do not
   * effect this class.
   */

  public static final int[] pseudoDocTypes ()
  {
    int[] pseudoDocTypesCopy = new int[pseudoDocTypes.length];
    System.arraycopy(pseudoDocTypes, 0, pseudoDocTypesCopy, 0, pseudoDocTypes.length);
    return pseudoDocTypesCopy;
  }

  // ================================================================================
  // Autocoded methods start
  // ================================================================================

  //#AUTOCODED

  // ================================================================================
  // Autocoded methods end
  // ================================================================================

  /**
   * Disabled constructor.
   */

  private DataEntityType ()
    throws IllegalAccessException
  {
    throw new IllegalAccessException("DataEntityType must not be instanciated");
  }
}
