<?xml version="1.0" encoding="ASCII"?>


<!--
  The MIT License (MIT)
  
  Copyright (c) 2010 Technische Universitaet Berlin
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
-->

<!--
  <dbh:method name="">
    <dbh:params>
      <dbh:param type="" name=""/>
      <dbh:param type="" name=""/>
      <dbh:param type="" name=""/>
      <dbh:param type="" name=""/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
-->

<dbh:DbHelper xmlns:dbh="http://www.mumie.net/xml-namespace/db-helper"
              xmlns:h="http://www.mumie.net/xml-namespace/html-in-javadoc"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://www.mumie.net/xml-namespace/db-helper DbHelper.xsd">

  <!-- ================================================================================ -->
  <!-- h1: Querying non-binary document data                                            -->
  <!-- ================================================================================ -->

  <dbh:method name="queryData">
    <dbh:params>
      <dbh:param name="docType" type="int"/>
      <dbh:param name="columns" type="String[]"/>
      <dbh:param name="onlyLatest" type="boolean"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the data specified by <h:code>columns</h:code> of the documents with the
      * specified type. If <h:code>onlyLatest</h:code> is true, only latest versions of the
      * documents are considered.
    </dbh:doc>
    <dbh:body>
      if ( ! DocType.exists(docType) )
        throw new IllegalArgumentException("Unknown document type: " + docType);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getTableName(docType, onlyLatest))
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDatum">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(this.filterColumn(column))
        FROM
        table(DbTable.DOC[type])
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getDatumAsString" returnType="String">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the document with the specified type and id as a
      * string
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet = this.queryDatum(type, id, column);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find document with type " + type + " and id " + id);
      String value = resultSet.getString(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDatum" logging="no">
    <dbh:params>
      <dbh:param name="document" type="Document"/>
      <dbh:param name="column" type="String"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified document.
    </dbh:doc>
    <dbh:body>
      return this.queryDatum(document.getType(), document.getId(), column);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryData">
    <dbh:params>
      <dbh:param name="type" type="int"/>
      <dbh:param name="id" type="int"/>
      <dbh:param name="columns" type="String[]"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.DOC[type])
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryData">
    <dbh:params>
      <dbh:param name="type" type="int"/>
      <dbh:param name="ids" type="int[]"/>
      <dbh:param name="columns" type="String[]"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents with the specified type and ids.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.DOC[type])
        WHERE
        column(DbColumn.ID) IN { values(ids) }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryData" logging="no">
    <dbh:params>
      <dbh:param name="type" type="int"/>
      <dbh:param name="id" type="int"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the the default columns for the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      return this.queryData(type, id, this.getDefaultColumns(type));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryData" logging="no">
    <dbh:params>
      <dbh:param name="document" type="Document"/>
      <dbh:param name="columns" type="String[]"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified document.
    </dbh:doc>
    <dbh:body>
      return this.queryData(document.getType(), document.getId(), columns);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDatumByQualifiedName">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="qualifiedName"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the documents with the specified type and qualified
      * name. If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only latest versions of
      * the documents are consdidered.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(this.filterColumn(column))
        FROM
        table(this.getTableName(type, onlyLatest))
        WHERE
        column(DbColumn.QUALIFIED_NAME) = value(qualifiedName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataByQualifiedName">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="qualifiedName"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents with the specified type and qualified
      * name. If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only latest versions of
      * the documents are consdidered.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getTableName(type, onlyLatest))
        WHERE
        column(DbColumn.QUALIFIED_NAME) = value(qualifiedName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataByPath" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="path"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents with the specified type and path.
      * If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only latest versions of
      * the documents are consdidered.
    </dbh:doc>
    <dbh:body>
      this.pathTokenizer.tokenize(path);
      String sectionPath = this.pathTokenizer.getSectionPath();
      String pureName = this.pathTokenizer.getPureName();
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getTableName(type, onlyLatest))
        WHERE
        column(DbColumn.CONTAINED_IN) = funcCall("section_id_for_path", 0, sectionPath)
        AND
        column(DbColumn.PURE_NAME) = value(pureName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getDatumAsInt" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the document with the specified type and
      * id as an int.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet = this.queryDatum(type, id, column);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find document with type " + type + " and id " + id);
      int value = resultSet.getInt(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDocuments">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents of the specified type. If
      * <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are
      * returned.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getTableName(type, onlyLatest))
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDocuments" logging="no">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the default columns for the documents of the specified type. If
      * <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are returned.
    </dbh:doc>
    <dbh:body>
      return this.queryDocuments(type, this.getDefaultColumns(type), onlyLatest);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying document references                                                 -->
  <!-- ================================================================================ -->

  <dbh:method name="queryDataOfRefTarget">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the document that is the target of the reference
      * given by the specified "from" and "to" document types and the specified reference id.
      * The reference attributes are included in the returned result set, too [this should
      * be removed in a future version].
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      String refTable = DbTable.REF[fromDocType][toDocType];
      if ( refTable == null )
        {
          <dbh:log number="2/2">"No reference table"</dbh:log>
          return null;
        }
      final String REF = "ref";
      final String DOC = "doc";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, REF) AS column(DbColumn.REF)
        column(DbColumn.LID, REF) AS column(DbColumn.LID)
        column(DbColumn.REF_TYPE, REF) AS column(DbColumn.REF_TYPE)
      </dbh:sqlComposer>
      for (int refAttrib = RefAttrib.first; refAttrib &lt;= RefAttrib.last; refAttrib++)
        {
          if ( RefAttrib.exists(refAttrib, fromDocType, toDocType) )
            {
              String column = RefAttrib.dbColumnOf[refAttrib];
              <dbh:sqlComposer>
                column(column, REF) AS column(column)
              </dbh:sqlComposer>
            }
        }
      <dbh:sqlComposer>
        columns(columns, DOC)
        FROM
        table(refTable) AS table(REF)
        table(DbTable.DOC[toDocType]) AS table(DOC)
        WHERE
        column(DbColumn.ID, REF) = value(refId)
        AND
        column(DbColumn.TO_DOC, REF) = column(DbColumn.ID, DOC)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log number="2/2">"query = " + query</dbh:log>
      return this.connection.createStatement().executeQuery(query);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDatumOfRefTarget">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the document that is the target of the reference
      * given by the specified "from" and "to" document types and the specified reference id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(column)
        FROM
        table(DbTable.DOC[toDocType])
        WHERE
        column(DbColumn.ID)
        IN
          {
            SELECT
            column(DbColumn.TO_DOC)
            FROM
            column(DbTable.REF[fromDocType][toDocType])
            WHERE
            column(DbColumn.ID) = value(refId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataOfRefOrigin">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the default columns of the document that is the origin of the reference given
      * by the specified "from" and "to" document types and the specified reference id. If
      * <h:code>onlyLatest</h:code> is true and the document is not the latest version, an
      * empty result set is returned.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.getDefaultColumns(fromDocType))
        FROM
        table(this.getTableName(fromDocType, onlyLatest))
        WHERE
        column(DbColumn.ID)
        IN
          {
            SELECT
            column(DbColumn.FROM_DOC)
            FROM
            column(DbTable.REF[fromDocType][toDocType])
            WHERE
            column(DbColumn.ID) = value(refId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReferencedDocs">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="fromDocId"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      Returns the ids of the targets of the specified references.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      String refTable = DbTable.REF[fromDocType][toDocType];
      if ( refTable == null )
        {
          <dbh:log number="2/2">"No reference table"</dbh:log>
          return null;
        }
      <dbh:sqlComposer>
        SELECT 
        column(DbColumn.TO_DOC)
        FROM
        table(refTable)
        WHERE
        column(DbColumn.FROM_DOC) = value(fromDocId)
        AND
        column(DbColumn.REF_TYPE) = value(refType);
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log number="2/2">"query = " + query</dbh:log>
      return this.connection.createStatement().executeQuery(query);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataOfReferencedDocs">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="fromDocId"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns columns for certain documents referenced from another document. The
      * former documents comprise those which are of a certain type
      * (<h:code>toDocType</h:code>) and are referenced with a certain reference type
      * (<h:code>refType</h:code>) from the latter document. The latter document is
      * specified by <h:code>fromDocType</h:code> and <h:code>fromDocId</h:code>. The
      * returned result set contains the specified columns plus the id, lid, type and
      * attributes of the reference. To avoid  name conflicts, The id of the referernce
      * is provided under the name {@link DbColumn#REF DbColumn.REF}.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      String refTable = DbTable.REF[fromDocType][toDocType];
      if ( refTable == null )
        {
          <dbh:log number="2/2">"No reference table"</dbh:log>
          return null;
        }
      final String REF = "ref";
      final String DOC = "doc";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, REF) AS column(DbColumn.REF)
        column(DbColumn.LID, REF) AS column(DbColumn.LID)
        column(DbColumn.REF_TYPE, REF) AS column(DbColumn.REF_TYPE)
      </dbh:sqlComposer>
      for (int refAttrib = RefAttrib.first; refAttrib &lt;= RefAttrib.last; refAttrib++)
        {
          if ( RefAttrib.exists(refAttrib, fromDocType, toDocType) )
            {
              String column = RefAttrib.dbColumnOf[refAttrib];
              <dbh:sqlComposer>
                column(column, REF) AS column(column)
              </dbh:sqlComposer>
            }
        }
      <dbh:sqlComposer>
        columns(this.filterColumns(columns, DOC))
        FROM
        table(refTable) AS table(REF)
        table(DbTable.DOC[toDocType]) AS table(DOC)
        WHERE
        column(DbColumn.FROM_DOC, REF) = value(fromDocId)
        AND
        column(DbColumn.TO_DOC, REF) = column(DbColumn.ID, DOC)
        AND
        column(DbColumn.REF_TYPE, REF) = value(refType)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log number="2/2">"query = " + query</dbh:log>
      return this.connection.createStatement().executeQuery(query);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataOfReferencedDocs" logging="no">
    <dbh:params>
      <dbh:param type="Document" name="fromDoc"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns columns for certain documents referenced from another document. The
      * former documents comprise those which are of a certain type
      * (<h:code>toDocType</h:code>) and are referenced with a certain reference type
      * (<h:code>refType</h:code>) from the latter document. The latter document is
      * specified by <h:code>document</h:code>. The
      * returned result set contains the specified columns plus the id, lid, type and
      * attributes of the reference. To avoid  name conflicts, The id of the referernce
      * is provided under the name {@link DbColumn#REF DbColumn.REF}.
    </dbh:doc>
    <dbh:body>
      return this.queryDataOfReferencedDocs
        (fromDoc.getType(), fromDoc.getId(), toDocType, refType, columns);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDataOfReferencingDocs">
    <dbh:params>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="toDocId"/>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns columns for certain documents referencing another document. The
      * former documents comprise those which are of a certain type
      * (<h:code>fromDocType</h:code>) and are referencing the latter document with a
      * certain reference type (<h:code>refType</h:code>). The latter document is
      * specified by <h:code>toDocType</h:code> and <h:code>toDocId</h:code>. The
      * returned result set contains the specified columns plus the id, lid, type and
      * attributes of the reference. To avoid  name conflicts, The id of the referernce
      * is provided under the name {@link DbColumn#REF DbColumn.REF}.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      String refTable = DbTable.REF[fromDocType][toDocType];
      if ( refTable == null )
        {
          <dbh:log number="2/2">"No reference table"</dbh:log>
          return null;
        }
      final String REF = "ref";
      final String DOC = "doc";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, REF) AS column(DbColumn.REF)
        column(DbColumn.LID, REF) AS column(DbColumn.LID)
        column(DbColumn.REF_TYPE, REF) AS column(DbColumn.REF_TYPE)
      </dbh:sqlComposer>
      for (int refAttrib = RefAttrib.first; refAttrib &lt;= RefAttrib.last; refAttrib++)
        {
          if ( RefAttrib.exists(refAttrib, toDocType, fromDocType) )
            {
              String column = RefAttrib.dbColumnOf[refAttrib];
              <dbh:sqlComposer>
                column(column, REF) AS column(column)
              </dbh:sqlComposer>
            }
        }
      <dbh:sqlComposer>
        columns(this.filterColumns(columns, DOC))
        FROM
        table(refTable) AS table(REF)
        table(DbTable.DOC[fromDocType]) AS table(DOC)
        WHERE
        column(DbColumn.TO_DOC, REF) = value(toDocId)
        AND
        column(DbColumn.FROM_DOC, REF) = column(DbColumn.ID, DOC)
        AND
        column(DbColumn.REF_TYPE, REF) = value(refType)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log number="2/2">"query = " + query</dbh:log>
      return this.connection.createStatement().executeQuery(query);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReferencedDocuments">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="targetDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents of type <h:code>targetDocType</h:code>
      * referenced in the document given by <h:code>docType</h:code> and <h:code>docId</h:code>
      * (type and id of the document) with a certain reference type (<h:code>refType</h:code>).
      * If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are
      * returned.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getTableName(targetDocType, onlyLatest))
        WHERE
        column(DbColumn.ID)
        IN
          {
            SELECT
            column(DbColumn.TO_DOC)
            FROM
            table(DbTable.REF[docType][targetDocType])
            WHERE
            column(DbColumn.FROM_DOC) = value(docId)
            AND
            column(DbColumn.REF_TYPE) = value(refType)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReferencedDocuments" logging="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="targetDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the default columns for the documents of type <h:code>targetDocType</h:code>
      * referenced in the document given by <h:code>docType</h:code> and <h:code>docId</h:code>
      * (type and id of the document) with a certain reference type (<h:code>refType</h:code>).
      * If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are
      * returned.
    </dbh:doc>
    <dbh:body>
      return this.queryReferencedDocuments
        (docType,
         docId,
         targetDocType,
         refType,
         this.getDefaultColumns(docType),
         onlyLatest);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReferencingDocuments">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="originDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents of type <h:code>targetDocType</h:code>
      * referencing the document given by <h:code>docType</h:code> and <h:code>docId</h:code>
      * (type and id of the document) with a certain reference type (<h:code>refType</h:code>).
      * If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are
      * returned.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getTableName(originDocType, onlyLatest))
        WHERE
        column(DbColumn.ID)
        IN
          {
            SELECT
            column(DbColumn.FROM_DOC)
            FROM
            table(DbTable.REF[originDocType][docType])
            WHERE
            column(DbColumn.TO_DOC) = value(docId)
            AND
            column(DbColumn.REF_TYPE) = value(refType)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReferencingDocuments" logging="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="originDocType"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the default columns for the documents of type <h:code>targetDocType</h:code>
      * referencing the document given by <h:code>docType</h:code> and <h:code>docId</h:code>
      * (type and id of the document) with a certain reference type (<h:code>refType</h:code>).
      * If <h:code>onlyLatest</h:code> is <h:code>true</h:code>, only newest versions are
      * returned.
    </dbh:doc>
    <dbh:body>
      return this.queryReferencingDocuments
        (docType,
         docId,
         originDocType,
         refType,
         this.getDefaultColumns(originDocType),
         onlyLatest);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryCorrectorDataOfRefTarget">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns of the corrector of the document that is the target of
      * the specified reference. 
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getTableName(DocType.JAVA_CLASS, true))
        WHERE
        column(DbColumn.ID) =
          {
            SELECT
            column(DbColumn.CORRECTOR)
            FROM
            table(DbTable.DOC[toDocType])
            WHERE
            column(DbColumn.ID) =
              {
                SELECT
                column(DbColumn.TO_DOC)
                FROM
                table(DbTable.REF[fromDocType][toDocType])
                WHERE
                column(DbColumn.ID) = value(refId)
              }
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getCorrectorQNameByProblemId" returnType="String">
    <dbh:params>
      <dbh:param type="int" name="problemId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the qualified name of the corrector of a document that is the target of a
      * reference. 
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
      SELECT
      column(DbColumn.QUALIFIED_NAME)
      FROM
      table(this.getTableName(DocType.JAVA_CLASS, true))
      WHERE
      column(DbColumn.ID) =
        {
          SELECT
          column(DbColumn.CORRECTOR)
          FROM
          table(DbTable.DOC[DocType.PROBLEM])
          WHERE
          column(DbColumn.ID) = value(problemId)
        }
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      String qualifiedName =
        (resultSet.next()
        ? resultSet.getString(DbColumn.QUALIFIED_NAME)
        : null);
      <dbh:log>"qualifiedName = " + qualifiedName</dbh:log>
      return qualifiedName;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getCorrectorLastModifiedByProblemId" returnType="long">
    <dbh:params>
      <dbh:param type="int" name="problemId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the last modification time of the corrector of a problem document. 
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log> 
      <dbh:sqlComposer>
      SELECT
      column(DbColumn.LAST_MODIFIED)
      FROM
      table(this.getTableName(DocType.JAVA_CLASS, true))
      WHERE
      column(DbColumn.ID) =
        {
          SELECT
          column(DbColumn.CORRECTOR)
          FROM
          table(DbTable.DOC[DocType.PROBLEM])
          WHERE
          column(DbColumn.ID) = value(problemId)
        }
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      long lastModified =
        (resultSet.next()
         ? resultSet.getTimestamp(DbColumn.LAST_MODIFIED).getTime()
         : -1);
      <dbh:log>"lastModified = " + lastModified</dbh:log>
      return lastModified;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReference">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="refId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the reference with the specified "from" document type, "to" document type, and
      * reference id. The returned result set comprises {@link DbColumn#ID DbColumn.ID},
      * {@link DbColumn#FROM_DOC DbColumn.FROM_DOC}, {@link DbColumn#TO_DOC DbColumn.TO_DOC},
      * {@link DbColumn#LID DbColumn.LID}, {@link DbColumn#REF_TYPE DbColumn.REF_TYPE}, and the
      * reference attribute columns.
    </dbh:doc>
    <dbh:body>
      String referenceTable = DbTable.REF[fromDocType][toDocType];
      if ( referenceTable == null )
        {
          <dbh:log number="2/2">"No reference table"</dbh:log>
	  return null;
        }
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        column(DbColumn.FROM_DOC)
        column(DbColumn.TO_DOC)
        column(DbColumn.LID)
        column(DbColumn.REF_TYPE)
      </dbh:sqlComposer>
      for (int refAttrib = RefAttrib.first; refAttrib &lt;= RefAttrib.last; refAttrib++)
        {
          if ( RefAttrib.exists(refAttrib, fromDocType, toDocType) )
            <dbh:sqlComposer>
              column(RefAttrib.dbColumnOf[refAttrib])
            </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        FROM
        table(referenceTable)
        WHERE
        column(DbColumn.ID) = value(refId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkIfReferenced" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="fromDocId"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="toDocId"/>
      <dbh:param type="int" name="refType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if a reference with the specified origin, target, and ref type exists, otherwise false.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.REF[fromDocType][toDocType])
        WHERE
        column(DbColumn.FROM_DOC) = value(fromDocId)
        AND
        column(DbColumn.TO_DOC) = value(toDocId)
        AND
        column(DbColumn.REF_TYPE) = value(refType)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean exists = resultSet.next();
      resultSet.close();
      <dbh:log>"Done. exists = " + exists</dbh:log>
      return exists;
    </dbh:body>
  </dbh:method>


  <dbh:method name="getProblemRef" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="problemId"/>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String REFS = "refs";
      final String GDIM = "gdim";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, REFS)
        FROM
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REFS)
        table(DbTable.GDIM[DocType.PROBLEM], GDIM)
        WHERE
        column(DbColumn.FROM_DOC, REFS) = value(worksheetId)
        AND
        column(DbColumn.TO_DOC, REFS) = column(DbColumn.GENERIC_DOCUMENT, GDIM)
        AND
        column(DbColumn.DOCUMENT, GDIM) = value(problemId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() ) throw new SQLException
        ("No reference found for real problem" + problemId + " and worksheetId " + worksheetId);
      int refId = resultSet.getInt(DbColumn.ID);
      if ( resultSet.next() ) this.logWarn
        (METHOD_NAME + ": Multiple references found for real problem" + problemId +
         " and worksheetId " + worksheetId);
      <dbh:log>"refId = " + refId</dbh:log>
      return refId;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating non-binary document data                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="updateData" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores the specified data for the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[docType])
        updateData(data)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateDatum" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="int" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a datum of the document with the specified type and id in the specified
      * column.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[docType])
        SET column(column) = value(value)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateDatum" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="boolean" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a datum of the document with the specified type and id in the specified
      * column.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[docType])
        SET column(column) = value(value)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocDatum" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="int" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a datum of the pseudo-document with the specified type and id in the specified
      * column.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[pseudoDocType])
        SET column(column) = value(value)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocDatum" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="boolean" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a datum of the pseudo-document with the specified type and id in the specified
      * column.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[pseudoDocType])
        SET column(column) = value(value)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeData" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores the specified data in the table corresponding to the specified document type.
      * Returns the id of the newly created document.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.DOC[docType])
        insertData(data)
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeData" target="PostgreSQLDbHelper" returnType="int"
              toInterface="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores the specified data in the table corresponding to the specified document type.
      * Returns the id of the newly created document.
    </dbh:doc>
    <dbh:body>
      String table = DbTable.DOC[docType];
      <dbh:sqlComposer>
        INSERT INTO
        table(table)
        insertData(data)
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="table"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateContainedIn" returnType="int" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="String" name="path"/>
      <dbh:param type="String" name="sectionPath"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      Changes the section of a document.
    </dbh:doc>
    <dbh:body>
      this.pathTokenizer.tokenize(path);
      String oldSectionPath = this.pathTokenizer.getSectionPath();
      String pureName = this.pathTokenizer.getPureName();
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[docType])
        SET column(DbColumn.CONTAINED_IN) = funcCall("section_id_for_path", 0, sectionPath)
        WHERE
        column(DbColumn.CONTAINED_IN) =  funcCall("section_id_for_path", 0, oldSectionPath)
        AND
        column(DbColumn.PURE_NAME) = value(pureName)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: VC threads                                                                   -->
  <!-- ================================================================================ -->

  <dbh:method name="storeVcThread" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="String" name="name"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Creates a new vc thread for the specified document type and with the specified name.
      * Returns the id of the new vc thread.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.VC_THREADS[docType])
        { column(DbColumn.NAME) }
        VALUES
        { value(name) }
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeVcThread" returnType="int" target="PostgreSQLDbHelper" toInterface="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="String" name="name"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Creates a new vc thread for the specified document type and with the specified name.
      * Returns the id of the new vc thread.
    </dbh:doc>
    <dbh:body>
      String table = DbTable.VC_THREADS[docType];
      <dbh:sqlComposer>
        INSERT INTO
        table(table)
        { column(DbColumn.NAME) }
        VALUES
        { value(name) }
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="table"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDocumentDataForVCThread">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="vcThreadId"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the document(s) with the specified type and
      * vc thread. If <h:code>onlyLatest</h:code> is true, only  only latest versions
      * of the documents are considered.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getTableName(docType, onlyLatest))
        WHERE
        column(DbColumn.VC_THREAD) = value(vcThreadId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing and updating document references                                     -->
  <!-- ================================================================================ -->

  <dbh:method name="storeReference" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="fromDocId"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="toDocId"/>
      <dbh:param type="String" name="lid"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="Map" name="attribs"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a reference and returns the autogenerated id.
    </dbh:doc>
    <dbh:body>
      Map data = new HashMap();
      data.put(DbColumn.FROM_DOC, new Integer(fromDocId));
      data.put(DbColumn.TO_DOC, new Integer(toDocId));
      if ( lid != null ) data.put(DbColumn.LID, lid);
      data.put(DbColumn.REF_TYPE, new Integer(refType));
      if ( attribs != null )
        {
          Iterator iterator = attribs.entrySet().iterator();
          while ( iterator.hasNext() )
            {
              Map.Entry entry = (Map.Entry)iterator.next();
              String name = (String)entry.getKey();
              Object value = entry.getValue();
              int refAttrib = RefAttrib.codeFor(name);
              if ( refAttrib == RefAttrib.UNDEFINED )
                throw new IllegalArgumentException("Unknown ref attrib name: " + name);
              if ( !RefAttrib.exists(refAttrib, fromDocType, toDocType, refType) )
                throw new IllegalArgumentException
                  ("For references " + fromDocType + "-" + toDocType + "(" + refType + "), " +
                   "ref attrib is not declared: " + refAttrib);
              data.put(RefAttrib.dbColumnOf[refAttrib], value);
            }
        }
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.REF[fromDocType][toDocType])
        insertData(data)
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeReference" returnType="int" target="PostgreSQLDbHelper"
              toInterface="no">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="fromDocId"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="toDocId"/>
      <dbh:param type="String" name="lid"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="Map" name="attribs"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a reference and returns the autogenerated id.
    </dbh:doc>
    <dbh:body>
      Map data = new HashMap();
      data.put(DbColumn.FROM_DOC, new Integer(fromDocId));
      data.put(DbColumn.TO_DOC, new Integer(toDocId));
      if ( lid != null ) data.put(DbColumn.LID, lid);
      data.put(DbColumn.REF_TYPE, new Integer(refType));
      if ( attribs != null )
        {
          Iterator iterator = attribs.entrySet().iterator();
          while ( iterator.hasNext() )
            {
              Map.Entry entry = (Map.Entry)iterator.next();
              String name = (String)entry.getKey();
              Object value = entry.getValue();
              int refAttrib = RefAttrib.codeFor(name);
              if ( refAttrib == RefAttrib.UNDEFINED )
                throw new IllegalArgumentException("Unknown ref attrib name: " + name);
              if ( !RefAttrib.exists(refAttrib, fromDocType, toDocType, refType) )
                throw new IllegalArgumentException
                  ("For references " + fromDocType + "-" + toDocType + "(" + refType + "), " +
                   "ref attrib is not declared: " + refAttrib);
              data.put(RefAttrib.dbColumnOf[refAttrib], value);
            }
        }
      String table = DbTable.REF[fromDocType][toDocType];
      if ( table == null )
        throw new SQLException("checkin fails. No references allowed from "
                                + DocType.nameFor[fromDocType] + " to "
                                + DocType.nameFor[toDocType]);
      <dbh:sqlComposer>
        INSERT INTO
        table(table)
        insertData(data)
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="table"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateRefTargets" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="oldToDocId"/>
      <dbh:param type="int" name="newToDocId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Updates all references pointing from a document of type <h:code>fromDocType</h:code>
      * to the document specified by <h:code>toDocType</h:code> and
      * <h:code>oldToDocId</h:code>. In all corresponding rows in the cooresponding reference
      * table, <h:code>oldToDocId</h:code> is changed to <h:code>newToDocId</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.REF[fromDocType][toDocType])
        SET
        column(DbColumn.TO_DOC) = value(newToDocId)
        WHERE
        column(DbColumn.TO_DOC) = value(oldToDocId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateCorrector" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="oldCorrectorId"/>
      <dbh:param type="int" name="newCorrectorId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Updates the corrector values of the documents with the specified type. In all
      * rows of in the cooresponding document table, <h:code>oldCorrectorId</h:code> is
      * changed to <h:code>newCorrectorId</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[docType])
        SET
        column(DbColumn.CORRECTOR) = value(newCorrectorId)
        WHERE
        column(DbColumn.CORRECTOR) = value(oldCorrectorId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying document authors                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="queryAuthors">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns all authors of the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.AUTHOR)
        column(DbColumn.ROLE)
        FROM
        table(DbTable.AUTHORS[docType])
        WHERE
        column(DbColumn.DOCUMENT) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing document authors                                                     -->
  <!-- ================================================================================ -->

  <dbh:method name="storeAuthorship" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores the specified user as an author of the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.AUTHORS[docType])
        { column(DbColumn.DOCUMENT) column(DbColumn.AUTHOR)}
        VALUES
        { value(docId) value(userId)}
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying document sources                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="queryTextSources">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the ids of all text sources of the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.SOURCE)
        FROM
        table(DbTable.REF_TEXT_SOURCE[docType])
        WHERE
        column(DbColumn.FROM_DOC) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryBinarySources">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the ids of all binary sources of the document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.SOURCE)
        FROM
        table(DbTable.REF_BINARY_SOURCE[docType])
        WHERE
        column(DbColumn.FROM_DOC) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying document members                                                    -->
  <!-- ================================================================================ -->

  <!-- DEPRECATED -->
  <dbh:method name="queryMembers">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns all members of the document given by <h:code>docType</h:code> and
      * <h:code>id</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      String table = DbTable.MEMBERS[docType];
      if ( table == null )
        {
          <dbh:log number="2/2">"No member table"</dbh:log>
          return null;
        }
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.DOCUMENT)
        column(DbColumn.MEMBER)
        column(DbColumn.ROLE)
        FROM
        table(table)
        WHERE
        column(DbColumn.DOCUMENT) = value(id)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log number="2/2">" query = " + query</dbh:log>
      return this.connection.createStatement().executeQuery(query);
    </dbh:body>
  </dbh:method>

  <!-- DEPRECATED -->
  <dbh:method name="queryMembers">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="int" name="role"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns data concerning the members of a document. The document is specified by
      * <h:code>docType</h:code> and <h:code>id</h:code>, i.e., its type and id. If
      * <h:code>role</h:code> is non-negative, the returned data are confined to members
      * hving that role. The data is specified by <h:code>columns</h:code>, which is an
      * array of columns of the database table corresponding to the type of the document.
      * The returned result comprises the specified <h:code>columns</h:code> plus the
      * {@link DbColumn#ROLE ROLE} column from the members table
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/2" printParams="yes">"Started"</dbh:log>
      final String USERS = "u";
      final String MEMBERS = "m";
      <dbh:sqlComposer>
        SELECT
        columns(columns, USERS)
        column(DbColumn.ROLE, MEMBERS)
        FROM
        table(DbTable.USERS) AS table(USERS)
        table(DbTable.MEMBERS[docType]) AS table(MEMBERS)
        WHERE
        column(DbColumn.ID, USERS) = column(DbColumn.MEMBER, MEMBERS)
        AND
        column(DbColumn.DOCUMENT, MEMBERS) = value(id)
      </dbh:sqlComposer>
      if ( role &gt; 0 )
        <dbh:sqlComposer>
          AND
          column(DbColumn.ROLE, MEMBERS) = value(role)
        </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Checking doucment membership                                                 -->
  <!-- ================================================================================ -->

  <dbh:method name="checkMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user with the specified user id is a member of the document
      * with the specified type and document id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.MEMBERS[docType])
        WHERE
        column(DbColumn.DOCUMENT) = value(docId)
        AND
        column(DbColumn.MEMBER) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isMember = resultSet.next();
      <dbh:log>"Done. isMember = " + isMember</dbh:log>
      return isMember;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying theme map entries                                                   -->
  <!-- ================================================================================ -->

  <dbh:method name="queryRealDocument"> <!-- This should be renamed to queryThemeMap -->
    <dbh:params>
      <dbh:param type="int" name="typeOfGeneric"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="int" name="themeId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the theme map entry for the generic document with the specified type and id
      * and the specified theme. This can be used to get the "real" document for a given
      * generic document and theme.
    </dbh:doc>
    <dbh:body>
      int typeOfReal = DocType.realOf[typeOfGeneric];
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.THEME)
        column(DbColumn.GENERIC_DOCUMENT)
        column(DbColumn.DOCUMENT)
        FROM
        table(DbTable.THEME_MAP[typeOfReal])
        WHERE
        column(DbColumn.GENERIC_DOCUMENT) = value(id)
        AND
        column(DbColumn.THEME) = value(themeId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating theme map entries                                           -->
  <!-- ================================================================================ -->

  <dbh:method name="storeThemeMapEntry" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="themeId"/>
      <dbh:param type="int" name="langId"/>
      <dbh:param type="int" name="genericDocId"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * 
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.GDIM[docType])
        {
          column(DbColumn.THEME)
          column(DbColumn.LANGUAGE)
          column(DbColumn.GENERIC_DOCUMENT)
          column(DbColumn.DOCUMENT)
        }
        VALUES
        {
          value(themeId)
          value(langId)
          value(genericDocId)
          value(docId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateThemeMapEntries" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="typeOfReal"/>
      <dbh:param type="int" name="oldIdOfReal"/>
      <dbh:param type="int" name="newIdOfReal"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Updates all theme map entries for the document with type <h:code>typeOfReal</h:code>
      * and id <h:code>oldIdOfReal</h:code>. In all these entries, <h:code>oldIdOfReal</h:code>
      * is replaced by <h:code>newIdOfReal</h:code>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.THEME_MAP[typeOfReal])
        SET
        column(DbColumn.DOCUMENT) = value(newIdOfReal)
        WHERE
        column(DbColumn.DOCUMENT) = value(oldIdOfReal)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="deleteGDIMEntries" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="typeOfReal"/>
      <dbh:param type="int" name="idOfReal"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Deletes all theme map entries for the document with type <h:code>typeOfReal</h:code>
      * and id <h:code>idOfReal</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE
        FROM
        table(DbTable.THEME_MAP[typeOfReal])
        WHERE
        column(DbColumn.DOCUMENT) = value(idOfReal)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Get Theme                                                      -->
  <!-- ================================================================================ -->
  
  <dbh:method name="getThemeForCourseById" returnType="int">
	  <dbh:params>
		  <dbh:param type="int" name="courseId"/>
	  </dbh:params>
	  <dbh:throws>
		  <dbh:throwable name="SQLException"/>
	  </dbh:throws>
	  <dbh:doc>
		  * Returns the theme of the class in which the course is part of.
	  </dbh:doc>
	  <dbh:body>
		  <dbh:log printParams="yes">"Started"</dbh:log>
		  <dbh:sqlComposer>
			  SELECT
			  column(DbColumn.THEME)
			  FROM
			  table(DbTable.CLASSES)
			  WHERE
			  column(DbColumn.ID) =
			  {
			  SELECT
			  column(DbColumn.CLASS)
			  FROM
			  table(DbTable.DOC[DocType.COURSE])
			  WHERE
			  column(DbColumn.ID) = value(courseId)
			  }
		  </dbh:sqlComposer>
		  String query = this.sqlComposer.getCode();
		  <dbh:log>"query = " + query</dbh:log>
		  ResultSet resultSet = this.connection.createStatement().executeQuery(query);
		  if ( ! resultSet.next() )
		  throw new SQLException
		  ("Can not find course for id \"" + courseId + "\" ");
		  int theme = resultSet.getInt(DbColumn.THEME);
                  if ( resultSet.wasNull() )
                     theme = Theme.DEFAULT;
		  <dbh:log>"Done. theme = " + theme</dbh:log>
		  return theme;
	  </dbh:body>
  </dbh:method>
  
  <dbh:method name="getThemeForWorksheetById" returnType="int">
	  <dbh:params>
		  <dbh:param type="int" name="worksheetId"/>
	  </dbh:params>
	  <dbh:throws>
		  <dbh:throwable name="SQLException"/>
	  </dbh:throws>
	  <dbh:doc>
		  * Returns the theme for the worksheet
	  </dbh:doc>
	  <dbh:body>
		  <dbh:log printParams="yes">"Started"</dbh:log>
		  final String REF = "ref";
		  final String COURSES = "courses";
		  final String CLASSES = "classes";
		  <dbh:sqlComposer>
			  SELECT
			  column(DbColumn.THEME)
			  FROM
			  table(DbTable.CLASSES),
			  table(DbTable.LATEST_DOC[DocType.COURSE]) AS table(COURSES),
			  table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF)
			  WHERE
			  column(DbColumn.CLASS, COURSES) = column(DbColumn.ID, CLASSES)
			  AND 
			  column(DbColumn.ID, COURSES) = column(DbColumn.FROM_DOC, REF)
			  AND
			  column(DbColumn.TO_DOC, REF) = value(worksheetId)
		  </dbh:sqlComposer>
		  String query = this.sqlComposer.getCode();
		  <dbh:log>"query = " + query</dbh:log>
		  ResultSet resultSet = this.connection.createStatement().executeQuery(query);
		  if ( ! resultSet.next() )
		  throw new SQLException
		  ("Can not find worksheet for id \"" + worksheetId + "\" ");
		  int theme = resultSet.getInt(DbColumn.THEME);
                  if ( resultSet.wasNull() )
                     theme = Theme.DEFAULT;
		  <dbh:log>"Done. theme = " + theme</dbh:log>
		  return theme;
	  </dbh:body>
  </dbh:method>
  
  
  
  
  <dbh:method name="getThemeForProblemRefId" returnType="int">
	  <dbh:params>
		  <dbh:param type="int" name="refId"/>
	  </dbh:params>
	  <dbh:throws>
		  <dbh:throwable name="SQLException"/>
	  </dbh:throws>
	  <dbh:doc>
		  * Returns the theme for the problem references
	  </dbh:doc>
	  <dbh:body>
		  <dbh:log printParams="yes">"Started"</dbh:log>
		  final String REF = "ref";
		  final String COURSES = "courses";
		  final String CLASSES = "classes";
		  final String GENREF = "genref";
		  <dbh:sqlComposer>
			  SELECT
			  column(DbColumn.THEME)
			  FROM
			  table(DbTable.CLASSES),
			  table(DbTable.LATEST_DOC[DocType.COURSE]) AS table(COURSES),
			  table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF)
			  table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM]) AS table(GENREF)
			  WHERE
			  column(DbColumn.CLASS, COURSES) = column(DbColumn.ID, CLASSES)
			  AND 
			  column(DbColumn.ID, COURSES) = column(DbColumn.FROM_DOC, REF)
			  AND
			  column(DbColumn.TO_DOC, REF) = column(DbColumn.FROM_DOC, GENREF)
			  AND
			  column(DbColumn.ID, GENREF) = value(refId)
		  </dbh:sqlComposer>
		  String query = this.sqlComposer.getCode();
		  <dbh:log>"query = " + query</dbh:log>
		  ResultSet resultSet = this.connection.createStatement().executeQuery(query);
		  if ( ! resultSet.next() )
		  	return PseudoDocType.UNDEFINED;	
		  int theme = resultSet.getInt(DbColumn.THEME);
                  if ( resultSet.wasNull() )
                     theme = Theme.DEFAULT;
		  <dbh:log>"Done. theme = " + theme</dbh:log>
		  return theme;
	  </dbh:body>
  </dbh:method>
  <!-- ================================================================================ -->
  <!-- h1: Querying GDIM entries                                                        -->
  <!-- ================================================================================ -->

  <dbh:method name="queryGDIM">
    <dbh:params>
      <dbh:param type="int" name="typeOfGeneric"/>
      <dbh:param type="int[]" name="idsOfGeneric"/>
      <dbh:param type="int" name="themeId"/>
      <dbh:param type="int" name="langId"/>
      <dbh:param type="boolean" name="withFallbacks"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * <h:p>
      *   Returns the GDIM entry for the generic document with the specified type and ids,
      *   the specified theme, and the specified language. If <h:code>withFallbacks</h:code>
      *   is <h:code>true</h:code> the returned result set contains the entries for the
      *   default theme and the default and neutral language, too.
      * </h:p>
      * <h:p>
      *   The returned result set has the following columns:
      * </h:p>
      * <h:ol>
      *   <h:li>{@link DbColumn#GENERIC_DOCUMENT} (id of the generic document)</h:li>
      *   <h:li>{@link DbColumn#LANGUAGE} (id of the language)</h:li>
      *   <h:li>{@link DbColumn#THEME} (id of the theme)</h:li>
      *   <h:li>{@link DbColumn#DOCUMENT} (id of the real document)</h:li>
      * </h:ol>
    </dbh:doc>
    <dbh:body>
      int typeOfReal = DocType.realOf[typeOfGeneric];
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.GENERIC_DOCUMENT)
        column(DbColumn.THEME)
        column(DbColumn.LANGUAGE)
        column(DbColumn.DOCUMENT)
        FROM
        table(DbTable.GDIM[typeOfReal])
        WHERE
        column(DbColumn.GENERIC_DOCUMENT) IN { values(idsOfGeneric) }
      </dbh:sqlComposer>
      if ( withFallbacks )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.THEME)
              IN { value(themeId), value(Theme.DEFAULT) }
            AND
            column(DbColumn.LANGUAGE)
              IN { value(langId), value(Lang.NEUTRAL), value(Lang.DEFAULT) }
          </dbh:sqlComposer>
        }
      else
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.THEME) = value(themeId)
            AND
            column(DbColumn.LANGUAGE) = value(langId)
          </dbh:sqlComposer>
        }
      <dbh:returnResultSet scrollable="yes"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryGDIM">
    <dbh:params>
      <dbh:param type="int" name="typeOfGeneric"/>
      <dbh:param type="int" name="idOfGeneric"/>
      <dbh:param type="int" name="themeId"/>
      <dbh:param type="int" name="langId"/>
      <dbh:param type="boolean" name="withFallbacks"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the GDIM entry for the generic document with the specified type and id,
      * the specified theme, and the specified language. If <h:code>withFallbacks</h:code>
      * is <h:code>true</h:code> the returned result set contains the entries for the
      * default theme and the default and neutral language, too.
    </dbh:doc>
    <dbh:body>
      return this.queryGDIM
        (typeOfGeneric, new int[] {idOfGeneric}, themeId, langId, withFallbacks);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying read/write permissions                                              -->
  <!-- ================================================================================ -->

  <dbh:method name="queryReadPermissions">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns of the  user groups which have read permission on the
      * document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      String permissionsTable = DbTable.DOCUMENT_READ_PERMISSIONS[docType];
      if ( permissionsTable == null )
        throw new SQLException("No read permissions table for document type: " + docType);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns, DbTable.USER_GROUPS))
        FROM
        table(DbTable.USER_GROUPS)
        table(permissionsTable)
        WHERE
        column(DbColumn.USER_GROUP, permissionsTable) = column(DbColumn.ID, DbTable.USER_GROUPS)
        AND
        column(DbColumn.DOCUMENT, permissionsTable) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Checking read/write permissions                                              -->
  <!-- ================================================================================ -->

  <dbh:method name="checkDocumentReadPermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user specified by <h:code>userId</h:code> may read 
      * the document specified by <h:code>docId</h:code> and <h:code>docType</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      String readPermissionsTable = DbTable.DOCUMENT_READ_PERMISSIONS[docType];
      if ( readPermissionsTable == null )
        throw new SQLException("No read permissions table for document type: " + docType);
      String documentTable = DbTable.DOC[docType];
      if ( documentTable == null )
        throw new SQLException("No document table for document type: " + docType);
      final String USER_GROUPS = "g";
      final String USER_GROUP_MEMBERS = "m";
      final String READ_PERMISSIONS = "r";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USER_GROUPS)
        FROM
        table(DbTable.USER_GROUPS, USER_GROUPS)
        table(DbTable.USER_GROUP_MEMBERS, USER_GROUP_MEMBERS)
        table(readPermissionsTable, READ_PERMISSIONS)
        WHERE
        value(userId) = column(DbColumn.MEMBER, USER_GROUP_MEMBERS)
        AND
        column(DbColumn.USER_GROUP, USER_GROUP_MEMBERS) = column(DbColumn.ID, USER_GROUPS)
        AND
        column(DbColumn.ID, USER_GROUPS) = column(DbColumn.USER_GROUP, READ_PERMISSIONS)
        AND
        column(DbColumn.DOCUMENT, READ_PERMISSIONS) = value(docId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkPseudoDocumentReadPermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user specified by <h:code>userId</h:code> may read 
      * the pseudo-document specified by <h:code>docId</h:code> and <h:code>pseudoDocType</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      String readPermissionsTable = DbTable.PSEUDODOC_READ_PERMISSIONS[pseudoDocType];
      if ( readPermissionsTable == null )
        throw new SQLException
          ("No read permissions table for pseudo-document type: " + pseudoDocType);
      String documentTable = DbTable.PSEUDO_DOC[pseudoDocType];
      if ( documentTable == null )
        throw new SQLException("No document table for document type: " + pseudoDocType);
      final String USER_GROUPS = "g";
      final String USER_GROUP_MEMBERS = "m";
      final String READ_PERMISSIONS = "r";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USER_GROUPS)
        FROM
        table(DbTable.USER_GROUPS, USER_GROUPS)
        table(DbTable.USER_GROUP_MEMBERS, USER_GROUP_MEMBERS)
        table(readPermissionsTable, READ_PERMISSIONS)
        WHERE
        value(userId) = column(DbColumn.MEMBER, USER_GROUP_MEMBERS)
        AND
        column(DbColumn.USER_GROUP, USER_GROUP_MEMBERS) = column(DbColumn.ID, USER_GROUPS)
        AND
        column(DbColumn.ID, USER_GROUPS) = column(DbColumn.USER_GROUP, READ_PERMISSIONS)
        AND
        column(DbColumn.PSEUDO_DOCUMENT, READ_PERMISSIONS) = value(docId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkReadPermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docNature"/>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user specified by <h:code>userId</h:code> may read the
      * (pseudo-)document specified by <h:code>docNature</h:code>, <h:code>docId</h:code> and
      * <h:code>docType</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
    switch ( docNature )
      {
      case Nature.DOCUMENT: return checkDocumentReadPermission(userId,type,docId);
      case Nature.PSEUDO_DOCUMENT: return checkPseudoDocumentReadPermission(userId,type,docId);
      default:
	throw new SQLException
	  ("Method " + METHOD_NAME + " no proper nature of document ('document' or 'pseudo_document') specified: " + docNature);
      }
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkWritePermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="vcThreadId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user with the specified id has write permission on the
      * vc thread with the specified document type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String USER_GROUP_MEMBERS = "m";
      final String WRITE_PERMISSIONS = "w";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP, USER_GROUP_MEMBERS)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, USER_GROUP_MEMBERS)
        table(DbTable.WRITE_PERMISSIONS[docType], WRITE_PERMISSIONS)
        WHERE
        column(DbColumn.USER_GROUP, USER_GROUP_MEMBERS) =
          column(DbColumn.USER_GROUP, WRITE_PERMISSIONS)
        AND
        column(DbColumn.VC_THREAD, WRITE_PERMISSIONS) = value(vcThreadId)
        AND
        column(DbColumn.MEMBER, USER_GROUP_MEMBERS) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkWritePermissionById" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user with the specified id has write permission on the
      * document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String MEM = "mem";
      final String PERM = "perm";
      final String DOC = "doc";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP, MEM)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, MEM)
        table(DbTable.WRITE_PERMISSIONS[docType], PERM)
        table(DbTable.DOC[docType], DOC)
        WHERE
        column(DbColumn.USER_GROUP, PERM) = column(DbColumn.USER_GROUP, MEM)  
        AND
        column(DbColumn.VC_THREAD, PERM) = column(DbColumn.VC_THREAD, DOC)
        AND
        column(DbColumn.MEMBER, MEM) = value(userId)
        AND
        column(DbColumn.ID, DOC) = value(docId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkPseudoDocWritePermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user with the specified id has write permission on the
      * pseudo-document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String MEM = "mem";
      final String PERM = "perm";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP, MEM)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, MEM)
        table(DbTable.PSEUDODOC_WRITE_PERMISSIONS[pseudoDocType], PERM)
        WHERE
        column(DbColumn.USER_GROUP, PERM) = column(DbColumn.USER_GROUP, MEM)  
        AND
        column(DbColumn.PSEUDO_DOCUMENT, PERM) = value(pseudoDocId)
        AND
        column(DbColumn.MEMBER, MEM) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkCreatePermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the specified user is allowed to create new  documents of the
      * specified type.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String MAY_CREATE_COLUMN = DbColumn.mayCreate[docType]; 
      final String USER_GROUP_MEMBERS = "m";
      final String USER_GROUPS = "g";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER, USER_GROUP_MEMBERS)
        column(MAY_CREATE_COLUMN, USER_GROUPS)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, USER_GROUP_MEMBERS)
        table(DbTable.USER_GROUPS, USER_GROUPS)
        WHERE
        column(DbColumn.MEMBER, USER_GROUP_MEMBERS) = value(userId)
        AND
        column(DbColumn.USER_GROUP, USER_GROUP_MEMBERS) = column(DbColumn.ID, USER_GROUPS)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = false;
      while ( resultSet.next() &amp;&amp; !hasPermission )
        hasPermission = resultSet.getBoolean(MAY_CREATE_COLUMN);
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkUserGroupReadPermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userGroupId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the user group specified by <h:code>userGroupId</h:code> may read 
      * the document specified by <h:code>docId</h:code> and <h:code>docType</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      String readPermissionsTable = DbTable.DOCUMENT_READ_PERMISSIONS[docType];
      if ( readPermissionsTable == null )
        throw new SQLException("No read permissions table for document type: " + docType);
      String documentTable = DbTable.DOC[docType];
      if ( documentTable == null )
        throw new SQLException("No document table for document type: " + docType);
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP)
        FROM
        table(readPermissionsTable)
        WHERE
        column(DbColumn.USER_GROUP) = value(userGroupId)
        AND
        column(DbColumn.DOCUMENT) = value(docId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkUserGroupWritePermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userGroupId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="vcThreadId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the specified user group may checkin new versions of documents
      * of the specified type and the specified vc thread.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP)
        FROM
        table(DbTable.WRITE_PERMISSIONS[docType])
        WHERE
        column(DbColumn.USER_GROUP) = value(userGroupId)
        AND
        column(DbColumn.VC_THREAD) = value(vcThreadId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      boolean hasPermission = resultSet.next();
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkUserGroupCreatePermission" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userGroupId"/>
      <dbh:param type="int" name="docType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether the specified user group may create new documents
      * of the specified type.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      String column = DbColumn.mayCreate[docType];
      ResultSet resultSet = this.queryUserGroupDatum(userGroupId, column);
      if ( resultSet == null )
        throw new SQLException("Result set null");
      if ( !resultSet.next() )
        throw new SQLException("Result set empty");
      boolean hasPermission = resultSet.getBoolean(column);
      <dbh:log>"hasPermission = " + hasPermission</dbh:log>
      return hasPermission;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/removing read/write permissions                                      -->
  <!-- ================================================================================ -->

  <dbh:method name="storeReadPermission" returnType="void">
    <dbh:params>
      <dbh:param type="int" name="docNature"/>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="userGroupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the read permission table for the pseudo_document with the specified
      * nature, type and id and the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
    switch ( docNature )
      {
      case Nature.DOCUMENT:
        {
          storeDocumentReadPermission(type,docId,userGroupId);
          <dbh:log printParams="no">"case DOCUMENT"</dbh:log>
          return;
        }
      case Nature.PSEUDO_DOCUMENT:
        {
          storePseudoDocumentReadPermission(type,docId,userGroupId);
          <dbh:log printParams="no">"case PSEUDO_DOCUMENT"</dbh:log>
          return;
        }
      default:
	throw new SQLException
	  ("Method " + METHOD_NAME + " no proper nature of document ('document' or 'pseudo_document') specified: " + docNature);
      }
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeDocumentReadPermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="userGroupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the document with the specified
      * type and idand the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.DOCUMENT_READ_PERMISSIONS[docType])
        { column(DbColumn.USER_GROUP) column(DbColumn.DOCUMENT) }
        VALUES
        { value(userGroupId) value(docId) }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <!-- TODO: Rename to storePseudoDocReadPermission, similar to
    storePseudoDocWritePermission -->
  <dbh:method name="storePseudoDocumentReadPermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="int" name="userGroupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the pseudo_document with the specified
      * type and id and the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.PSEUDODOC_READ_PERMISSIONS[pseudoDocType])
        { column(DbColumn.USER_GROUP) column(DbColumn.PSEUDO_DOCUMENT) }
        VALUES
        { value(userGroupId) value(pseudoDocId) }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storePseudoDocumentReadPermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="String" name="userGroupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the pseudo_document with the specified
      * type and id and the user group specified by its name.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.PSEUDODOC_READ_PERMISSIONS[pseudoDocType])
        { column(DbColumn.USER_GROUP) column(DbColumn.PSEUDO_DOCUMENT) }
        VALUES
        { 
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(userGroupName)
          },
          value(pseudoDocId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeDocumentWritePermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="vcThreadId"/>
      <dbh:param type="int" name="userGroupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the specified document type,
      * vc thread, and user group
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.WRITE_PERMISSIONS[docType])
        { column(DbColumn.USER_GROUP) column(DbColumn.VC_THREAD) }
        VALUES
        { value(userGroupId), value(vcThreadId) }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storePseudoDocWritePermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="int" name="userGroupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the specified pseudo-document type,
      * pseudo-document id, and user group
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.PSEUDODOC_WRITE_PERMISSIONS[pseudoDocType])
        { column(DbColumn.USER_GROUP) column(DbColumn.PSEUDO_DOCUMENT) }
        VALUES
        { value(userGroupId), value(pseudoDocId) }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storePseudoDocWritePermission" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="String" name="userGroupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new entry in the write permission table for the pseudo_document with the specified
      * type and id and the user group specified by its name.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.PSEUDODOC_WRITE_PERMISSIONS[pseudoDocType])
        { column(DbColumn.USER_GROUP) column(DbColumn.PSEUDO_DOCUMENT) }
        VALUES
        { 
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(userGroupName)
          },
          value(pseudoDocId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeAllReadPermissionsForPseudoDoc" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.PSEUDODOC_READ_PERMISSIONS[type])
        WHERE
        column(DbColumn.PSEUDO_DOCUMENT) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeAllWritePermissionsForPseudoDoc" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.PSEUDODOC_WRITE_PERMISSIONS[type])
        WHERE
        column(DbColumn.PSEUDO_DOCUMENT) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying and storing binary document data                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="queryBinaryDatum" returnType="void">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="OutputStream" name="outputStream" log="no"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong with the database."/>
      <dbh:throwable name="IOException" doc="if something goes wrong with stream writing"/>
    </dbh:throws>
    <dbh:doc>
      * Writes a binary datum of the document with the specified type and id to
      * <h:code>outputStream</h:code>. The binary is specified as the column
      * <h:code>column</h:code> of the corresponding document table.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet datum = this.queryDatum(docType, id, column);
      datum.next();
      InputStream inputStream = datum.getBlob(column).getBinaryStream();
      <dbh:log>"Writing"</dbh:log>
      byte[] buffer = new byte[1024];
      int amount = 0;
      while ( (amount = inputStream.read(buffer)) > 0 )
        outputStream.write(buffer, 0, amount);
      outputStream.flush();
      inputStream.close();
      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryBinaryDatum"  returnType="void" target="PostgreSQLDbHelper"
              toInterface="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="OutputStream" name="outputStream" log="no"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong with the database."/>
      <dbh:throwable name="IOException" doc="if something goes wrong with stream writing"/>
    </dbh:throws>
    <dbh:doc>
      * Writes a binary datum of the document with the specified type and id to
      * <h:code>outputStream</h:code>. The binary is specified as the column
      * <h:code>column</h:code> of the corresponding document table.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(column)
        FROM
        table(DbTable.DOC[docType])
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query + ", autocommit = " + this.connection.getAutoCommit()</dbh:log>
      Statement statement = this.connection.createStatement();
      ResultSet resultSet = statement.executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("Result set empty");
      int oid = resultSet.getInt(1);
      resultSet.close();
      this.queryLargeObject(oid, outputStream);
      statement.close();
      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateBinaryDatum" target="PostgreSQLDbHelper" returnType="void">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="InputStream" name="inputStream" log="no"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores a binary datum of the document with the specified type and id in the specified
      * column. The binary datum is read from  <h:code>inputStream</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      int oid = this.storeLargeObject(inputStream);
      this.updateDatum(docType, id, column, oid);
      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryBinaryDatum" returnType="void" logging="no">
    <dbh:params>
      <dbh:param type="Document" name="document"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="OutputStream" name="outputStream"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IOException" doc="if something goes wrong with stream writing"/>
    </dbh:throws>
    <dbh:doc>
      * Writes a binary datum of the specified document to
      * <h:code>outputStream</h:code>. The binary is specified as the column
      * <h:code>column</h:code> of the corresponding document table.
    </dbh:doc>
    <dbh:body>
      this.queryBinaryDatum 
        (document.getType(), document.getId(), column, outputStream);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryAndWriteBlobDatum" returnType="void" logging="no">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="OutputStream" name="outputStream" log="no"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IOException" doc="if something goes wrong with stream writing"/>
    </dbh:throws>
    <dbh:doc>
      * An alias for
      * {@link #queryBinaryDatum(int,int,String,OutputStream) queryBinaryDatum}
      * @deprecated Use
      * {@link #queryBinaryDatum(int,int,String,OutputStream) queryBinaryDatum}
      * instead
    </dbh:doc>
    <dbh:body>
      this.queryBinaryDatum 
        (docType, docId, column, outputStream);
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryAndWriteBlobDatum" returnType="void" logging="no">
    <dbh:params>
      <dbh:param type="Document" name="document"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="OutputStream" name="outputStream"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IOException" doc="if something goes wrong with stream writing"/>
    </dbh:throws>
    <dbh:doc>
      * An alias for
      * {@link #queryBinaryDatum(Document,String,OutputStream) queryBinaryDatum}
      * @deprecated Use
      * {@link #queryBinaryDatum(Document,String,OutputStream) queryBinaryDatum}
      * instead
    </dbh:doc>
    <dbh:body>
      this.queryBinaryDatum 
        (document, column, outputStream);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying pseudo-document data                                                -->
  <!-- ================================================================================ -->

  <dbh:method name="queryPseudoDocData">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for all pseudo-documents of the specified type.
    </dbh:doc>
    <dbh:body>
      if ( ! PseudoDocType.exists(pseudoDocType) )
        throw new IllegalArgumentException("Unknown pseudo-document type: " + pseudoDocType);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getPseudoDocTableName(pseudoDocType))
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocData">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int[]" name="pseudoDocIds"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the pseudo-documents with the specified type and ids.
    </dbh:doc>
    <dbh:body>
      if ( !PseudoDocType.exists(pseudoDocType) )
        throw new IllegalArgumentException("Unknown pseudo-document type: " + pseudoDocType);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getPseudoDocTableName(pseudoDocType))
        WHERE
        column(DbColumn.ID) IN { values(pseudoDocIds) }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocData">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the pseudo-documents with the specified type and id.
    </dbh:doc>
    <dbh:body>
      if ( ! PseudoDocType.exists(pseudoDocType) )
        throw new IllegalArgumentException("Unknown pseudo-document type: " + pseudoDocType);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getPseudoDocTableName(pseudoDocType))
        WHERE
        column(DbColumn.ID) = value(pseudoDocId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocDatum">
    <dbh:params>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="int" name="pseudoDocId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the pseudo-documents with the specified type and id.
    </dbh:doc>
    <dbh:body>
      if ( ! PseudoDocType.exists(pseudoDocType) )
        throw new IllegalArgumentException("Unknown pseudo-document type: " + pseudoDocType);
      <dbh:sqlComposer>
        SELECT
        column(this.filterColumn(column))
        FROM
        table(this.getPseudoDocTableName(pseudoDocType))
        WHERE
        column(DbColumn.ID) = value(pseudoDocId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getPseudoDocDatumAsString" returnType="String">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the pseudo-document with the specified type and
      * id as a string
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet = this.queryPseudoDocDatum(type, id, column);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find pseudo-document with type " + type + " and id " + id);
      String value = resultSet.getString(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getPseudoDocDatumAsInt" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the pseudo-document with the specified type and
      * id as an int.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet = this.queryPseudoDocDatum(type, id, column);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find pseudo-document with type " + type + " and id " + id);
      int value = resultSet.getInt(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocDataByPath" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="path"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the pseudo-documents with the specified type and
      * path.
    </dbh:doc>
    <dbh:body>
      this.pathTokenizer.tokenize(path);
      String sectionPath = this.pathTokenizer.getSectionPath();
      String pureName = this.pathTokenizer.getPureName();
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getPseudoDocTableName(type))
        WHERE
        column(DbColumn.CONTAINED_IN) = funcCall("section_id_for_path", 0, sectionPath)
        AND
        column(DbColumn.PURE_NAME) = value(pureName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocDataBySyncId">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the pseudo-documents with the specified type and
      * sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(this.getPseudoDocTableName(type))
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocDatumBySyncId">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the pseudo-documents with the specified type and
      * sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
	column(this.filterColumn(column))
        FROM
        table(this.getPseudoDocTableName(type))
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getPseudoDocDatumBySyncIdAsInt" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the pseudo-document with the specified type and
      * sync id as an int.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet = this.queryPseudoDocDatumBySyncId(type, syncId, column);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find pseudo-document with type " + type + " and syncId " + syncId);
      int value = resultSet.getInt(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryLangIdByCode" returnType="int" target="AbstractDbHelper">
    <dbh:params>
      <dbh:param type="String" name="code"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id for the language with the specified code.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.LANGUAGES)
        WHERE
        column(DbColumn.CODE) = value(code)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("No language found for code: " + code);
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating pseudo-document data                                        -->
  <!-- ================================================================================ -->

  <dbh:method name="storePseudoDocData" returnType="int" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Inserts the specified data into the table for pseudo-documents of the specified
      * type, returns the id of the newly created pseudo-document.
    </dbh:doc>
    <dbh:body>
      String table = DbTable.PSEUDO_DOC[type];
      <dbh:sqlComposer>
        INSERT INTO
        table(table)
        insertData(data)
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="table"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocData" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the pseudo-document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[type])
        updateData(data)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocDatum" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="String" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the pseudo-document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[type])
        SET
        column(column) = value(value)
        WHERE
        column(DbColumn.ID) = value(id)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocDataBySyncId" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the pseudo-document with the specified type and sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[type])
        updateData(data)
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updatePseudoDocDatumBySyncId" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="column"/>
      <dbh:param type="int" name="value"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the pseudo-document with the specified type and sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.PSEUDO_DOC[type])
        SET
        column(column) = value(value)
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying pseudo document read/write permissions                              -->
  <!-- ================================================================================ -->

  <dbh:method name="queryPseudoDocReadPermissions">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns of the user groups which have read permission on the
      * pseudo-document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      String permissionsTable = DbTable.PSEUDODOC_READ_PERMISSIONS[type];
      if ( permissionsTable == null )
        throw new SQLException("No read permissions table for pseudo-document type: " + type);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns, DbTable.USER_GROUPS))
        FROM
        table(DbTable.USER_GROUPS)
        table(permissionsTable)
        WHERE
        column(DbColumn.USER_GROUP, permissionsTable) = column(DbColumn.ID, DbTable.USER_GROUPS)
        AND
        column(DbColumn.PSEUDO_DOCUMENT, permissionsTable) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocWritePermissions">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns of the user groups which have write permission on the
      * pseudo-document with the specified type and id.
    </dbh:doc>
    <dbh:body>
      String permissionsTable = DbTable.PSEUDODOC_WRITE_PERMISSIONS[type];
      if ( permissionsTable == null )
        throw new SQLException("No write permissions table for pseudo-document type: " + type);
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns, DbTable.USER_GROUPS))
        FROM
        table(DbTable.USER_GROUPS)
        table(permissionsTable)
        WHERE
        column(DbColumn.USER_GROUP, permissionsTable) = column(DbColumn.ID, DbTable.USER_GROUPS)
        AND
        column(DbColumn.PSEUDO_DOCUMENT, permissionsTable) = value(id)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying content objects                                                     -->
  <!-- ================================================================================ -->

  <dbh:method name="queryContentObjectsInSection">
    <dbh:params>
      <dbh:param type="int" name="sectionId"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents and pseudo-documents which are in
      * the specified section.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(filterColumns(columns))
        FROM
        table(onlyLatest ? DbTable.LATEST_CONTENT_OBJECTS : DbTable.CONTENT_OBJECTS)
        WHERE
        column(DbColumn.CONTAINED_IN) = value(sectionId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryDocumentsInSection">
    <dbh:params>
      <dbh:param type="int" name="sectionId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the documents with the specified type
      * which are in the specified section.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getTableName(docType, onlyLatest))
        WHERE
        column(DbColumn.CONTAINED_IN) = value(sectionId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryPseudoDocsInSection">
    <dbh:params>
      <dbh:param type="int" name="sectionId"/>
      <dbh:param type="int" name="pseudoDocType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the pseudo-documents with the specified type
      * which are in the specified section.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getPseudoDocTableName(pseudoDocType))
        WHERE
        column(DbColumn.CONTAINED_IN) = value(sectionId)
        AND
        column(DbColumn.ID) != value(sectionId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryContentObjects">
    <dbh:params>
      <dbh:param type="ContentObjectItem[]" name="items"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specifies documents and pseudo-documents.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(filterColumns(columns))
        FROM
        table(onlyLatest ? DbTable.LATEST_CONTENT_OBJECTS : DbTable.CONTENT_OBJECTS)
        WHERE
          {
            column(DbColumn.DOC_TYPE) = value(items[0].getTypeName())
            AND
            column(DbColumn.ID) = value(items[0].getId())
          }
      </dbh:sqlComposer>
      for (int i = 1; i &lt; items.length; i++)
        {
          <dbh:sqlComposer>
            OR
              {
                column(DbColumn.DOC_TYPE) = value(items[i].getTypeName())
                AND
                column(DbColumn.ID) = value(items[i].getId())
              }
          </dbh:sqlComposer>
        }
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryContentObjectData" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="String" name="sectionPath"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the (pseudo-)documents which the specified pure name
      * in the section with the specified path.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(filterColumns(columns))
        FROM
        table(onlyLatest ? DbTable.LATEST_CONTENT_OBJECTS : DbTable.CONTENT_OBJECTS)
        WHERE
        column(DbColumn.CONTAINED_IN) = funcCall("section_id_for_path", 0, sectionPath)
        AND
        column(DbColumn.PURE_NAME) = value(pureName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryContentObjectData">
    <dbh:params>
      <dbh:param type="String" name="path"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="onlyLatest"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the (pseudo-)documents which the specified path.
    </dbh:doc>
    <dbh:body>
      this.pathTokenizer.tokenize(path);
      String sectionPath = this.pathTokenizer.getSectionPath();
      String pureName = this.pathTokenizer.getPureName();
      return this.queryContentObjectData(sectionPath, pureName, columns, onlyLatest);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying user data                                                           -->
  <!-- ================================================================================ -->

  <dbh:method name="checkAuthStatus" returnType="int" logging="yes">
    <dbh:params>
      <dbh:param type="String" name="loginName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns whether a user with this loginName exists and has a password
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.PASSWORD)
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.LOGIN_NAME) = value(loginName)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
      {
        return User.AUTHSTATUS_NONE;
      }
      else
      {
        if ( resultSet.getString(DbColumn.PASSWORD) == null )
          return User.AUTHSTATUS_EXTERNAL;
        else
          return User.AUTHSTATUS_MUMIE;
      }
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserDatum" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified user.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocDatum(PseudoDocType.USER, userId, this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserData" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified user.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocData(PseudoDocType.USER, userId, this.filterColumns(columns));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserDatum" logging="no">
    <dbh:params>
      <dbh:param type="User" name="user"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified user.
    </dbh:doc>
    <dbh:body>
      return this.queryUserDatum(user.getId(),this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserData" logging="no">
    <dbh:params>
      <dbh:param type="User" name="user"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified user.
    </dbh:doc>
    <dbh:body>
      return queryUserData(user.getId(),this.filterColumns(columns));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserData">
    <dbh:params>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="String" name="password"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the user with the specified login name
      * and password.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.LOGIN_NAME) = value(loginName)
        AND
        column(DbColumn.PASSWORD) = value(password)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserData">
    <dbh:params>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the user with the specified login name
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.LOGIN_NAME) = value(loginName)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="searchUsers">
    <dbh:params>
      <dbh:param type="int" name="id"/>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="String" name="firstName"/>
      <dbh:param type="String" name="surname"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the users with the specified data.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
      </dbh:sqlComposer>
      String condKeyword = "WHERE";
      if ( id != Id.UNDEFINED )
        {
          <dbh:sqlComposer>
            token(condKeyword) column(DbColumn.ID) = value(id)
          </dbh:sqlComposer>
          condKeyword = "AND";
        }
      if ( loginName != null )
        {
          <dbh:sqlComposer>
            token(condKeyword) column(DbColumn.LOGIN_NAME) = value(loginName)
          </dbh:sqlComposer>
          condKeyword = "AND";
        }
      if ( firstName != null )
        {
          <dbh:sqlComposer>
            token(condKeyword) column(DbColumn.FIRST_NAME) = value(firstName)
          </dbh:sqlComposer>
          condKeyword = "AND";
        }
      if ( surname != null )
        {
          <dbh:sqlComposer>
            token(condKeyword) column(DbColumn.SURNAME) = value(surname)
          </dbh:sqlComposer>
          condKeyword = "AND";
        }
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkIfUserExists" returnType="boolean">
    <dbh:params>
      <dbh:param type="String" name="loginName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified login name exists, otherwise false
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.LOGIN_NAME) = value(loginName)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean exists = resultSet.next();
      resultSet.close();
      <dbh:log>"Done. exists = " + exists</dbh:log>
      return exists;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkIfUserHasCredentials" returnType="boolean">
    <dbh:params>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="boolean" name="withoutSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified login name exists and has a non-NULL
      * password, otherwise false.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.LOGIN_NAME) = value(loginName)
        AND
        column(DbColumn.PASSWORD) IS NOT NULL
      </dbh:sqlComposer>
      if ( withoutSyncId )
        {
        <dbh:sqlComposer>
          AND
          column(DbColumn.SYNC_ID) IS NULL
        </dbh:sqlComposer>
        }
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean hasCredentials = resultSet.next();
      resultSet.close();
      <dbh:log>"Done. hasCredentials = " + hasCredentials</dbh:log>
      return hasCredentials;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkIfUserPureNameExists" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="sectionId"/>
      <dbh:param type="String" name="pureName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if a user with the specified pure name exists in the specified section,
      otherwise false.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.PURE_NAME) = value(pureName)
        AND
        column(DbColumn.CONTAINED_IN) = value(sectionId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean exists = resultSet.next();
      resultSet.close();
      <dbh:log>"Done. exists = " + exists</dbh:log>
      return exists;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating user data                                                   -->
  <!-- ================================================================================ -->

  <dbh:method name="storeUserData" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Inserts the specified data into the user table and returns the id of the newly
      * created user.
    </dbh:doc>
    <dbh:body>
      return this.storePseudoDocData(PseudoDocType.USER, data);
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeUserData" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="String" name="passwordEncrypted"/>
      <dbh:param type="String" name="firstName"/>
      <dbh:param type="String" name="surname"/>
      <dbh:param type="String" name="matrNumber"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Inserts the specified data into the user table and returns the id of the newly
      * created user.
    </dbh:doc>
    <dbh:body>
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( syncId == null &amp;&amp; ( loginName == null || passwordEncrypted == null ) )
        throw new IllegalArgumentException
          ("If sync id is not specified, both login name and password must be specified");
      Map data = new HashMap();
      data.put(DbColumn.SYNC_ID, syncId);
      data.put(DbColumn.PURE_NAME, pureName);
      data.put(DbColumn.CONTAINED_IN, new Integer(containedIn));
      data.put(DbColumn.LOGIN_NAME, loginName);
      if ( passwordEncrypted != null )
        {
           data.put(DbColumn.PASSWORD, passwordEncrypted);
        }
      //Passwords may be null
      //else throw new IllegalArgumentException("Missing password");
      if ( firstName != null )
        data.put(DbColumn.FIRST_NAME, firstName);
      if ( surname != null )
        data.put(DbColumn.SURNAME, surname);
      <!-- matriculation numbers not supported yet -->
      return this.storeUserData(data);
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateUserData" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the specified user.
    </dbh:doc>
    <dbh:body>
      return this.updatePseudoDocData(PseudoDocType.USER, userId, data);
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateUserData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="loginName"/>
      <dbh:param type="String" name="passwordEncrypted"/>
      <dbh:param type="String" name="firstName"/>
      <dbh:param type="String" name="surname"/>
      <dbh:param type="String" name="matrNumber"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates the data of the user with the specified sync id.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      Map data = new HashMap();
      if ( loginName != null )
        data.put(DbColumn.LOGIN_NAME, loginName);
      if ( passwordEncrypted != null )
        data.put(DbColumn.PASSWORD, passwordEncrypted);
      if ( firstName != null )
        data.put(DbColumn.FIRST_NAME, firstName);
      if ( surname != null )
        data.put(DbColumn.SURNAME, surname);
      <!-- matriculation numbers not supperted yet -->
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.USERS)
        updateData(data)
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying user group data                                                     -->
  <!-- ================================================================================ -->

  <dbh:method name="queryUserGroupDatum" logging="no">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified user group.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocDatum(PseudoDocType.USER_GROUP, groupId, this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupData" logging="no">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified user group.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocData(PseudoDocType.USER_GROUP, groupId, this.filterColumns(columns));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupData">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="String[]" name="columns"/>
      <dbh:param type="boolean" name="withCreatePermissions"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns plus the create permission columns for the
      * specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
      </dbh:sqlComposer>
      if ( withCreatePermissions )
        <dbh:sqlComposer>
          columns(DbColumn.mayCreate)
        </dbh:sqlComposer>
      <dbh:sqlComposer>
        FROM
        table(DbTable.USER_GROUPS)
        WHERE
        column(DbColumn.ID) = value(groupId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupData">
    <dbh:params>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the user group with the specified name.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USER_GROUPS)
        WHERE
        column(DbColumn.NAME) = value(name)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getUserGroupDatumAsInt" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the user group with the specified name and
      * resturns it as an int.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(column)
        FROM
        table(DbTable.USER_GROUPS)
        WHERE
        column(DbColumn.NAME) = value(name)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not find user group with name \"" + name + "\"");
      int value = resultSet.getInt(column);
      <dbh:log>"Done. value = " + value</dbh:log>
      return value;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating user group data                                             -->
  <!-- ================================================================================ -->

  <dbh:method name="storeUserGroupData" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Inserts the specified data into the user group table and returns the id of the
      * newly created user group.
    </dbh:doc>
    <dbh:body>
      return this.storePseudoDocData(PseudoDocType.USER_GROUP, data);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying user group memberships                                              -->
  <!-- ================================================================================ -->

  <dbh:method name="queryUserGroupMembers">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the {@link DbColumn#MEMBER MEMBER} column for the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.USER_GROUP) = value(groupId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupMembers">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified user group from the detailed user
      * group member table.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USER_GROUP_MEMBERS_DETAILED)
        WHERE
        column(DbColumn.USER_GROUP) = value(groupId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupMember">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="int" name="memberId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified user in the specified
      * user group from the detailed user group member table.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USER_GROUP_MEMBERS_DETAILED)
        WHERE
        column(DbColumn.USER_GROUP) = value(groupId)
        AND
        column(DbColumn.MEMBER) = value(memberId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupMembersAsList" returnType="List" logging="no">
    <dbh:params>
      <dbh:param type="int" name="groupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id's of the members of the specifed user group as a list of
      * {@link Integer Integer} objects.
    </dbh:doc>
    <dbh:body>
      ResultSet resultSet = this.queryUserGroupMembers(groupId);
      List memberIds = new ArrayList();
      while ( resultSet.next() )
        memberIds.add(new Integer(resultSet.getInt(DbColumn.MEMBER)));
      return memberIds;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkUserGroupMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="groupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns <h:code>true</h:code> id the specified user is a member of the specified
      * user group, otherwise <h:code>false</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isMember = resultSet.next();
      <dbh:log>"Done. isMember = " + isMember</dbh:log>
      return isMember;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkUserGroupMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="String" name="userSyncId"/>
      <dbh:param type="String" name="groupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns <h:code>true</h:code> id the specified user is a member of the specified
      * user group, otherwise <h:code>false</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) IN
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
          }
        AND
        column(DbColumn.USER_GROUP) IN
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(groupName)
          }
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isMember = resultSet.next();
      <dbh:log>"Done. isMember = " + isMember</dbh:log>
      return isMember;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Adding/removing/changing user group memberships                              -->
  <!-- ================================================================================ -->

  <dbh:method name="addMemberToUserGroup" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="groupId"/>
      <dbh:param type="boolean" name="admin"/>
      <dbh:param type="boolean" name="readDefault"/>
      <dbh:param type="boolean" name="writeDefault"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified user group with the specified
      * attributes.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.USER_GROUP_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.USER_GROUP)
          column(DbColumn.ADMIN)
        }
        VALUES
        {
          value(userId)
          value(groupId)
          value(admin)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addMemberToUserGroup" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="groupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified user group. Same as
      * {@link #addMemberToUserGroup(int,int,boolean,boolean,boolean) addMemberToUserGroup(userId, groupId, false, false, false)}.
    </dbh:doc>
    <dbh:body>
      return this.addMemberToUserGroup(userId, groupId, false, false, false);
    </dbh:body>
  </dbh:method>

  <dbh:method name="addMemberToUserGroup" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String" name="groupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.USER_GROUP_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.USER_GROUP)
        }
        VALUES
        {
          value(userId) , 
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(groupName)
          }
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addMemberToUserGroup" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="userSyncId"/>
      <dbh:param type="String" name="groupName"/>
      <dbh:param type="boolean" name="admin"/>
      <dbh:param type="boolean" name="readDefault"/>
      <dbh:param type="boolean" name="writeDefault"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified user group with the specified
      * attributes.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.USER_GROUP_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.USER_GROUP)
          column(DbColumn.ADMIN)
        }
        VALUES
        {
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
          },{
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(groupName)
          },
          value(admin)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addMemberToUserGroup" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="String" name="userSyncId"/>
      <dbh:param type="String" name="groupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified user group. Same as
      * {@link #addMemberToUserGroup(String,String,boolean,boolean,boolean) addMemberToUserGroup(userSyncId, groupName, false, false, false)}.
    </dbh:doc>
    <dbh:body>
      return this.addMemberToUserGroup(userSyncId, groupName, false, false, false);
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeMemberFromUserGroup" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="groupId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the specified user from the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
        AND
        column(DbColumn.USER_GROUP) = value(groupId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeMemberFromUserGroup" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="userSyncId"/>
      <dbh:param type="String" name="groupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the specified user from the specified user group.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) IN
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
          }
        AND
        column(DbColumn.USER_GROUP) IN
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USER_GROUPS)
            WHERE
            column(DbColumn.NAME) = value(groupName)
          }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeMemberFromAllUserGroups" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the specified user from all user groups.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying user groups for a user                                              -->
  <!-- ================================================================================ -->
  
  <dbh:method name="queryUserGroups">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id's of the user groups the specified user is a member of. The
      * id;s are contained in the {@link DbColumn#USER_GROUP USER_GROUP} column of
      * the returned result set; which is the only column in it.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER_GROUP)
        FROM
        table(DbTable.USER_GROUP_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
  
  <dbh:method name="queryUserGroups">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns from the user group table for those user groups
      * the specified user is a member of.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USER_GROUPS)
        WHERE
        column(DbColumn.ID) IN
          {
            SELECT
            column(DbColumn.USER_GROUP)
            FROM
            table(DbTable.USER_GROUP_MEMBERS)
            WHERE
            column(DbColumn.MEMBER) = value(userId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupsAsList" returnType="List" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id's of the user groups the specified user is an menmber of
      * as a list of {@link Integer Integer} objects.
    </dbh:doc>
    <dbh:body>
      List userGroupIds = new ArrayList();
      ResultSet resultSet = this.queryUserGroups(userId);
      while ( resultSet.next() )
        userGroupIds.add(new Integer(resultSet.getInt(DbColumn.USER_GROUP)));
      return userGroupIds;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserGroupNamesAsList" returnType="List" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the names of the user groups the specified user is an menmber of
      * as a list of strings.
    </dbh:doc>
    <dbh:body>
      List userGroupNames = new ArrayList();
      ResultSet resultSet = this.queryUserGroups(userId, new String[] {DbColumn.NAME});
      while ( resultSet.next() )
        userGroupNames.add(resultSet.getString(DbColumn.NAME));
      return userGroupNames;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryAllUserGroups"> <!-- TODO: rename -->
    <dbh:params>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns from the user group table.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USER_GROUPS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Checking if a user is a member of a certain group                            -->
  <!-- ================================================================================ -->

  <!-- TODO: Throw an exception if the group does not exist -->
  <dbh:method name="checkUserGroupMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String" name="groupName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a member of the specified group
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String MEM = "mem";
      final String UGR = "ugr";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.NAME, UGR)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, MEM),
        table(DbTable.USER_GROUPS, UGR)
        WHERE
        column(DbColumn.MEMBER, MEM) = value(userId)
        AND
        column(DbColumn.USER_GROUP, MEM) = column(DbColumn.ID, UGR)
        AND
        column(DbColumn.NAME, UGR) = value(groupName)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isMember = resultSet.next();
      <dbh:log>"Done. isMember = " + isMember</dbh:log>
      return isMember;
    </dbh:body>
  </dbh:method>

  <!-- TODO: Derive from checkUserGroupMembership -->
  <dbh:method name="checkAdmin" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a member of the admin group.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String MEM = "mem";
      final String UGR = "ugr";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.NAME, UGR)
        FROM
        table(DbTable.USER_GROUP_MEMBERS, MEM),
        table(DbTable.USER_GROUPS, UGR)
        WHERE
        column(DbColumn.MEMBER, MEM) = value(userId)
        AND
        column(DbColumn.USER_GROUP, MEM) = column(DbColumn.ID, UGR)
        AND
        column(DbColumn.NAME, UGR) = value(UserGroupName.ADMINS)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isAdmin = resultSet.next();
      <dbh:log>"Done. isAdmin = " + isAdmin</dbh:log>
      return isAdmin;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Getting id for sync id.                                                      -->
  <!-- ================================================================================ -->

  <dbh:method name="getIdForSyncId" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="boolean" name="failIfInexistent"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id of the pseudo-document woith the specified type and sync id. 
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.PSEUDO_DOC[type])
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      int id = Id.UNDEFINED;
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( resultSet.next() )
        id = resultSet.getInt(DbColumn.ID);
      else if ( failIfInexistent )
        throw new SQLException
          ("No " + PseudoDocType.nameFor(type) + " found for syncId: " + syncId);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getIdForSyncId" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="syncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id of the pseudo-document woith the specified type and sync id. 
    </dbh:doc>
    <dbh:body>
      return this.getIdForSyncId(type, syncId, true);
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying e-learning class data                                               -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassDatum" logging="no">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocDatum(PseudoDocType.CLASS, classId, this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryClassData" logging="no">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocData(PseudoDocType.CLASS, classId, this.filterColumns(columns));
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating e-learning class data                                       -->
  <!-- ================================================================================ -->

  <dbh:method name="storeClassData" returnType="int" logging="no">
    <dbh:params>
      <dbh:param type="Map" name="data"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Inserts the specified data into the e-learning class table and returns the id
      * of the newly created e-learning class.
    </dbh:doc>
    <dbh:body>
      return this.storePseudoDocData(PseudoDocType.CLASS, data);
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeClassData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="semesterSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new e-learning class in the database. Returns the id of the
      * new e-learning class.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      if ( semesterSyncId == null )
        throw new IllegalArgumentException("Missing semester");
      Map data = new HashMap();
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.CLASSES)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
          column(DbColumn.DESCRIPTION)
          column(DbColumn.SEMESTER)
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
          value(description)
          ,
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.SEMESTERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(semesterSyncId)
          }
        }
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeClassData" returnType="int" target="PostgreSQLDbHelper"
              toInterface="no">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="semesterSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new e-learning class in the database. Returns the id of the
      * new e-learning class.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      if ( semesterSyncId == null )
        throw new IllegalArgumentException("Missing semester");
      Map data = new HashMap();
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.CLASSES)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
          column(DbColumn.SEMESTER)
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            value(description)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
          ,
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.SEMESTERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(semesterSyncId)
          }
        }
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="DbTable.CLASSES"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateClassData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="semesterSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates a row in the database table {@link DbTable#CLASSES CLASSES} with the given
      * <h:code>name</h:code>, <h:code>description</h:code>, and semester given by
      * <h:code>semesterSyncId</h:code>; the row being specified by <h:code>syncId</h:code>.
      * The arguments <h:code>name</h:code>, <h:code>description</h:code>, and
      * <h:code>semesterSyncId</h:code> may be null, in which case the according database
      * column is left unchanged.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/3" printParams="yes">"Started"</dbh:log>

      if ( name == null &amp;&amp; description == null &amp;&amp; semesterSyncId == null)
        {
          <dbh:log number="2-3/3">"Nothing to do"</dbh:log>
          return -1;
        }

      <dbh:sqlComposer>
        UPDATE
        table(DbTable.CLASSES)
        SET
      </dbh:sqlComposer>

      if ( name != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.NAME) = value(name)
          </dbh:sqlComposer>
        }

      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION) = value(description)
          </dbh:sqlComposer>
        }

      if ( semesterSyncId != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.SEMESTER) =
              {
                SELECT
                column(DbColumn.ID)
                FROM
                table(DbTable.SEMESTERS)
                WHERE
                column(DbColumn.SYNC_ID) = value(semesterSyncId)
             }
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>

      <dbh:executeUpdate expectedRowCount="1" withLogNumber="2/3"/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying e-learning class tutorials                                          -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassTutorials">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the tutorials of the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.TUTORIALS_EXT)
        WHERE
        column(DbColumn.CLASS) = value(classId)
        </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying e-learning class lecturers                                          -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassLecturers">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the lecturers of the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.ID) IN
          {
            SELECT
            column(DbColumn.LECTURER)
            FROM
            table(DbTable.CLASS_LECTURERS)
            WHERE
            column(DbColumn.CLASS) = value(classId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Adding/removing e-learning class lecturers                                   -->
  <!-- ================================================================================ -->

  <dbh:method name="addClassLecturer" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the lecturers of the the specified class.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.CLASS_LECTURERS)
        {
          column(DbColumn.CLASS)
          column(DbColumn.LECTURER)
        }
        VALUES
        {
          value(classId)
          value(userId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addClassLecturer" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="classSyncId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the user specified by <h:code>userId</h:code> to the lecturers of the
      * class specified by <h:code>classSyncId</h:code>. This is done by an
      * <h:code>INSERT</h:code> in the table {@link DbTable.CLASS_LECTURERS CLASS_LECTURERS}.
    </dbh:doc>
    <dbh:body>
      if ( classSyncId == null )
	throw new IllegalArgumentException("classSyncId must not be null");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.CLASS_LECTURERS)
        {
          column(DbColumn.CLASS)
          column(DbColumn.LECTURER)
        }
        VALUES
        {
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.SYNC_ID) = value(classSyncId)
          } ,
          value(userId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addClassLecturer" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="classSyncId"/>
      <dbh:param type="String" name="lecturerSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the user specified by <h:code>lecturerSyncId</h:code> to the lecturers of the
      * class specified by <h:code>classSyncId</h:code>. This is done by an
      * <h:code>INSERT</h:code> in the table {@link DbTable.CLASS_LECTURERS CLASS_LECTURERS}.
    </dbh:doc>
    <dbh:body>
      if ( classSyncId == null )
	throw new IllegalArgumentException("classSyncId must not be null");
      if ( lecturerSyncId == null )
	throw new IllegalArgumentException("lecturerSyncId must not be null");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.CLASS_LECTURERS)
        {
          column(DbColumn.CLASS)
          column(DbColumn.LECTURER)
        }{
          SELECT
          column(DbColumn.ID, DbTable.CLASSES)
          column(DbColumn.ID, DbTable.USERS)
          FROM
          table(DbTable.CLASSES)
          table(DbTable.USERS)
          WHERE
          column(DbColumn.SYNC_ID, DbTable.CLASSES) = value(classSyncId)
          AND
          column(DbColumn.SYNC_ID, DbTable.USERS) = value(lecturerSyncId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeClassLecturer" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="classSyncId"/>
      <dbh:param type="String" name="lecturerSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the user specified by <h:code>lecturerSyncId</h:code> from the lecturers of
      *  the class specified by <h:code>classSyncId</h:code>. This is done by an
      * <h:code>DELETE</h:code> in the table {@link DbTable.CLASS_LECTURERS CLASS_LECTURERS}.
    </dbh:doc>
    <dbh:body>
      if ( classSyncId == null )
	throw new IllegalArgumentException("classSyncId must not be null");
      if ( lecturerSyncId == null )
	throw new IllegalArgumentException("lecturerSyncId must not be null");
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.CLASS_LECTURERS)
        WHERE
        column(DbColumn.CLASS) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.SYNC_ID) = value(classSyncId)
          }
        AND
        column(DbColumn.LECTURER) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(lecturerSyncId)
          }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeClassLecturers" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="classSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes all lecturers of the the class specified by <h:code>classSyncId</h:code>, so that
      * the class has no lecturers any more. This is done by a <h:code>DELETE</h:code> in the
      * table {@link DbTable.CLASS_LECTURERS CLASS_LECTURERS}.
    </dbh:doc>
    <dbh:body>
      if ( classSyncId == null )
	throw new IllegalArgumentException("classSyncId must not be null");
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.CLASS_LECTURERS)
        WHERE
        column(DbColumn.CLASS) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.SYNC_ID) = value(classSyncId)
          }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeLecturerFromAllClasses" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.CLASS_LECTURERS)
        WHERE
        column(DbColumn.LECTURER) = value(userId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Get class                                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="getClassForWorksheetById" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the class for the worksheet
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String REF = "ref";
      final String COURSES = "courses";
      final String CLASSES = "classes";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.CLASS)
        FROM
        table(DbTable.CLASSES),
        table(DbTable.LATEST_DOC[DocType.COURSE]) AS table(COURSES),
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF)
        WHERE
        column(DbColumn.CLASS, COURSES) = column(DbColumn.ID, CLASSES)
        AND 
        column(DbColumn.ID, COURSES) = column(DbColumn.FROM_DOC, REF)
        AND
        column(DbColumn.TO_DOC, REF) = value(worksheetId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( ! resultSet.next() )
        throw new SQLException("Can not find worksheet for id \"" + worksheetId + "\" ");
      int classId = resultSet.getInt(DbColumn.CLASS);
      if ( resultSet.wasNull() )
        classId = Id.UNDEFINED;
      <dbh:log>"Done. class = " + classId</dbh:log>
      return classId;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getClassForProblemRefId" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="refId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the class for the problem references
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String REF = "ref";
      final String COURSES = "courses";
      final String CLASSES = "classes";
      final String GENREF = "genref";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.CLASS)
        FROM
        table(DbTable.CLASSES),
        table(DbTable.LATEST_DOC[DocType.COURSE]) AS table(COURSES),
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM]) AS table(GENREF)
        WHERE
        column(DbColumn.CLASS, COURSES) = column(DbColumn.ID, CLASSES)
        AND 
        column(DbColumn.ID, COURSES) = column(DbColumn.FROM_DOC, REF)
        AND
        column(DbColumn.TO_DOC, REF) = column(DbColumn.FROM_DOC, GENREF)
        AND
        column(DbColumn.ID, GENREF) = value(refId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( ! resultSet.next() )
        throw new SQLException("Can not find ref for id \"" + refId + "\" ");
      int classId = resultSet.getInt(DbColumn.CLASS);
      if ( resultSet.wasNull() )
        classId = Id.UNDEFINED;
      <dbh:log>"Done. class = " + classId</dbh:log>
      return classId;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Adding courses to a class                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="setClassForCourses" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="classSyncId"/>
      <dbh:param type="int[]" name="courseIds"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[DocType.COURSE])
        SET
        column(DbColumn.CLASS) =
        {
          SELECT
          column(DbColumn.ID)
          FROM
          table(DbTable.PSEUDO_DOC[PseudoDocType.CLASS])
          WHERE
          column(DbColumn.SYNC_ID) = value(classSyncId)
        }
        WHERE
        column(DbColumn.ID) IN { values(courseIds) }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="setClassForCourseByVCThread" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="courseVCThread"/>
      <dbh:param type="String" name="classSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Sets the class of the latest coourse with the specified vc thread to the class with
      * the specified sync id.
    </dbh:doc>
    <dbh:body>
      int classId = this.getPseudoDocDatumBySyncIdAsInt
        (PseudoDocType.CLASS, classSyncId, DbColumn.ID);
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.DOC[DocType.COURSE])
        SET
        column(DbColumn.CLASS) = value(classId)
        WHERE
        column(DbColumn.ID) =
        {
          SELECT
          column(DbColumn.ID)
          FROM
          table(this.getTableName(DocType.COURSE, true))
          WHERE
          column(DbColumn.VC_THREAD) = value(courseVCThread)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying e-learning class members                                            -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassMembers">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the members of the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.ID) IN
          {
            SELECT
            column(DbColumn.MEMBER)
            FROM
            table(DbTable.TUTORIAL_MEMBERS)
            WHERE
            column(DbColumn.CLASS) = value(classId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying e-learning class semester                                           -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassSemester">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the semester of the specified e-learning class.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.SEMESTERS)
        WHERE
        column(DbColumn.ID) IN
          {
            SELECT
            column(DbColumn.SEMESTER)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.ID) = value(classId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying tutorial data                                                       -->
  <!-- ================================================================================ -->

  <dbh:method name="queryTutorialDatum" logging="no">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified tutorial.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocDatum(PseudoDocType.TUTORIAL, tutorialId, this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryTutorialData" logging="no">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified tutorial.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocData(PseudoDocType.TUTORIAL, tutorialId, this.filterColumns(columns));
    </dbh:body>
  </dbh:method>

  <dbh:method name="getTutorialIdsForMember" returnType="int[]">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the ids of the tutorials the user with the specified id
      * is a member of.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.TUTORIAL)
        FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId);
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      IntList values = new IntList();
      while ( resultSet.next() ) values.add(resultSet.getInt(DbColumn.TUTORIAL));
      int[] tutorialIds = values.toIntArray();
      <dbh:log>"tutorialIds = " + LogUtil.arrayToString(tutorialIds)</dbh:log>
      return tutorialIds;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating tutorial data                                               -->
  <!-- ================================================================================ -->

  <dbh:method name="storeTutorialData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="tutorSyncId"/>
      <dbh:param type="String" name="classSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new tutorial with the specified data in the database. Returns the new id.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      if ( classSyncId == null )
        throw new IllegalArgumentException("Missing classSyncId");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIALS)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
          column(DbColumn.TUTOR)
          column(DbColumn.CLASS)
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            value(description)
          </dbh:sqlComposer>
        }
      if ( tutorSyncId != null )
        {
          <dbh:sqlComposer>
            ,{ 
               <!-- tutorId -->
               SELECT
               column(DbColumn.ID)
               FROM
               table(DbTable.USERS)
               WHERE
               column(DbColumn.SYNC_ID) = value(tutorSyncId)
             }
          </dbh:sqlComposer>
          }
      <dbh:sqlComposer>
          ,{
            <!-- classId -->
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.SYNC_ID) = value(classSyncId)
          }
        }
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeTutorialData" returnType="int" target="PostgreSQLDbHelper"
              toInterface="no">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="tutorSyncId"/>
      <dbh:param type="String" name="classSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new tutorial with the specified data in the database. Returns the new id.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      if ( classSyncId == null )
        throw new IllegalArgumentException("Missing classSyncId");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIALS)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
          column(DbColumn.TUTOR)
          column(DbColumn.CLASS)
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            value(description)
          </dbh:sqlComposer>
        }
      if ( tutorSyncId != null )
        {
          <dbh:sqlComposer>
            ,{ 
               <!-- tutorId -->
               SELECT
               column(DbColumn.ID)
               FROM
               table(DbTable.USERS)
               WHERE
               column(DbColumn.SYNC_ID) = value(tutorSyncId)
             }
          </dbh:sqlComposer>
          }
      <dbh:sqlComposer>
          ,{
            <!-- classId -->
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.CLASSES)
            WHERE
            column(DbColumn.SYNC_ID) = value(classSyncId)
          }
        }
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="DbTable.TUTORIALS"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateTutorialData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
      <dbh:param type="String" name="tutorSyncId"/>
      <dbh:param type="String" name="classSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Updates a row in the database table {@link DbTable#TUTORIALS TUTORIALS} setting
      * columns <h:code>name</h:code> and <h:code>description</h:code> to the given
      * values, column <h:code>tutor</h:code> to the (JAPS's) id of the row in
      * {@link DbTable#USERS USERS} specified by <h:code>tutorSyncId</h:code> and column
      * <h:code>class</h:code> to the (JAPS's) id of the row in {@link DbTable#CLASSES CLASSES}
      * specified by <h:code>classSyncId</h:code>. (Performing subselects for the latter)
      * The row in {@link DbTable#TUTORIALS TUTORIALS} is being specified by
      * <h:code>syncId</h:code>. The arguments <h:code>name</h:code>,
      * <h:code>description</h:code>, <h:code>tutorSyncId</h:code>, and
      * <h:code>classSyncId</h:code> may be null, in which case the according database column
      * is left unchanged.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/3" printParams="yes">"Started"</dbh:log>

      if ( name == null &amp;&amp;
           description == null &amp;&amp;
           tutorSyncId == null &amp;&amp;
           classSyncId == null)
        {
          <dbh:log number="2-3/3">"Nothing to do"</dbh:log>
          return -1;
        }

      <dbh:sqlComposer>
        UPDATE
        table(DbTable.TUTORIALS)
        SET
      </dbh:sqlComposer>

      if ( name != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.NAME) = value(name)
          </dbh:sqlComposer>
        }

      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION) = value(description)
          </dbh:sqlComposer>
        }

      if ( tutorSyncId != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.TUTOR) =
              {
                SELECT
                column(DbColumn.ID)
                FROM
                table(DbTable.USERS)
                WHERE
                column(DbColumn.SYNC_ID) = value(tutorSyncId)
              }
          </dbh:sqlComposer>
        }

      if ( classSyncId != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.CLASS) =
              {
                SELECT
                column(DbColumn.ID)
                FROM
                table(DbTable.CLASSES)
                WHERE
                column(DbColumn.SYNC_ID) = value(classSyncId)
              }
          </dbh:sqlComposer>
        }

      <dbh:sqlComposer>
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>

      <dbh:executeUpdate expectedRowCount="1" withLogNumber="2/3"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeTutorFromAllTutorials" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.TUTORIALS)
        SET
        column(DbColumn.TUTOR) = NULL
        WHERE
        column(DbColumn.TUTOR) = value(userId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying tutorial memberships                                                -->
  <!-- ================================================================================ -->

  <dbh:method name="queryTutorialMembers">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the data specified by <h:code>columns</h:code> of the members of the
      * tutorial specified by <h:code>tutorialId</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.ID)
        IN
          {
            SELECT
            column(DbColumn.MEMBER)
            FROM
            table(DbTable.TUTORIAL_MEMBERS)
            WHERE
            column(DbColumn.TUTORIAL) = value(tutorialId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkTutorialMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="String" name="userSyncId"/>
      <dbh:param type="String" name="tutorialSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns <h:code>true</h:code> id the specified user is a member of the specified
      * tutorial, otherwise <h:code>false</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
          }
        AND
        column(DbColumn.TUTORIAL) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.TUTORIALS)
            WHERE
            column(DbColumn.SYNC_ID) = value(tutorialSyncId)
          }
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isMember = resultSet.next();
      <dbh:log>"Done. isMember = " + isMember</dbh:log>
      return isMember;
    </dbh:body>
  </dbh:method>
  
  <dbh:method name="queryTutorialsOfUser">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns from the tutorial table for those tutorials
      * the specified user is a member of.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(this.filterColumns(columns))
        FROM
        table(DbTable.TUTORIALS_EXT)
        WHERE
        column(DbColumn.ID) IN
          {
            SELECT
            column(DbColumn.TUTORIAL)
            FROM
            table(DbTable.TUTORIAL_MEMBERS)
            WHERE
            column(DbColumn.MEMBER) = value(userId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Adding/removing/changing tutorial memberships                                -->
  <!-- ================================================================================ -->

  <dbh:method name="addMemberToTutorial" returnType="void" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="tutorialId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified tutorial. Same as
      * {@link #addMemberToTutorial(int,int,int) addMemberToTutorial(userId, groupId, this.queryTutorialDatum(tutorialId, DbColumn.CLASS))}.
    </dbh:doc>
    <dbh:body>
      ResultSet resultSet = queryTutorialDatum(tutorialId, DbColumn.CLASS);
      if ( resultSet.next() )
        {
          int classId = resultSet.getInt(DbColumn.CLASS);
          this.addMemberToTutorial(userId, tutorialId, classId);
        }
    </dbh:body>
  </dbh:method>

  <dbh:method name="addMemberToTutorial" returnType="int" logging="no" access="protected">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the specified user to the specified tutorial.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIAL_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
        }
        VALUES
        {
          value(userId)
          value(tutorialId)
          value(classId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addTutorialMember" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the user with the specified id to the specified tutorial.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIAL_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
        }{
          SELECT
          value(userId) AS column(DbColumn.MEMBER)
          column(DbColumn.ID) AS column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
          FROM
          table(DbTable.TUTORIALS)
          WHERE
          column(DbColumn.ID, DbTable.TUTORIALS) = value(tutorialId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addTutorialMember" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="tutorialSyncId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the user with the specified id to the specified tutorial.
    </dbh:doc>
    <dbh:body>
      if ( tutorialSyncId == null )
        throw new IllegalArgumentException("Tutorial sync id null");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIAL_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
        }{
          SELECT
          value(userId) AS column(DbColumn.MEMBER)
          column(DbColumn.ID) AS column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
          FROM
          table(DbTable.TUTORIALS)
          WHERE
          column(DbColumn.SYNC_ID, DbTable.TUTORIALS) = value(tutorialSyncId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="addTutorialMember" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="tutorialSyncId"/>
      <dbh:param type="String" name="userSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Adds the user specified by <h:code>userSyncId</h:code> to the tutorial specified by
      * <h:code>tutorialSyncId</h:code>.
    </dbh:doc>
    <dbh:body>
      if ( tutorialSyncId == null )
        throw new IllegalArgumentException("Tutorial sync id null");
      if ( userSyncId == null )
        throw new IllegalArgumentException("User sync id null");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.TUTORIAL_MEMBERS)
        {
          column(DbColumn.MEMBER)
          column(DbColumn.TUTORIAL)
          column(DbColumn.CLASS)
        }{
          SELECT
          column(DbColumn.ID, DbTable.USERS)
          column(DbColumn.ID, DbTable.TUTORIALS)
          column(DbColumn.CLASS, DbTable.TUTORIALS)
          FROM
          table(DbTable.USERS)
          table(DbTable.TUTORIALS)
          WHERE
          column(DbColumn.SYNC_ID, DbTable.USERS) = value(userSyncId)
          AND
          column(DbColumn.SYNC_ID, DbTable.TUTORIALS) = value(tutorialSyncId)
        }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeTutorialMember" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the user specified by <h:code>userId</h:code> from the tutorial specified
      * by <h:code>tutorialId</h:code>.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
        AND
        column(DbColumn.TUTORIAL) = value(tutorialId)
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeTutorialMember" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="tutorialSyncId"/>
      <dbh:param type="String" name="userSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the user specified by <h:code>userSyncId</h:code> from the tutorial specified
      * by <h:code>tutorialSyncId</h:code>.
    </dbh:doc>
    <dbh:body>
      if ( tutorialSyncId == null )
        throw new IllegalArgumentException("Tutorial sync id null");
      if ( userSyncId == null )
        throw new IllegalArgumentException("User sync id null");
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
          }
        AND
        column(DbColumn.TUTORIAL) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.TUTORIALS)
            WHERE
            column(DbColumn.SYNC_ID) = value(tutorialSyncId)
          }
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="removeMemberFromAllTutorials" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Removes the specified user from all tutorials.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        DELETE FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="changeUserTutorial" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="oldTutorialSyncId"/>
      <dbh:param type="String" name="newTutorialSyncId"/>
      <dbh:param type="String" name="userSyncId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Moves the user specified by <h:code>userSyncId</h:code> from the tutorial specified
      * by <h:code>oldTutorialSyncId</h:code> to the tutorial specified by
      * <h:code>newTutorialSyncId</h:code>.
    </dbh:doc>
    <dbh:body>
      if ( oldTutorialSyncId == null )
        throw new IllegalArgumentException("Old tutorial sync id null");
      if ( newTutorialSyncId == null )
        throw new IllegalArgumentException("New tutorial sync id null");
      if ( userSyncId == null )
        throw new IllegalArgumentException("User sync id null");
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.TUTORIAL_MEMBERS)
        SET
        column(DbColumn.TUTORIAL) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.TUTORIALS)
            WHERE
            column(DbColumn.SYNC_ID) = value(newTutorialSyncId)
          }
        WHERE
        column(DbColumn.MEMBER) =
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.USERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(userSyncId)
            AND
            column(DbColumn.TUTORIAL) =
              {
                SELECT
                column(DbColumn.ID)
                FROM
                table(DbTable.TUTORIALS)
                WHERE
                column(DbColumn.SYNC_ID) = value(oldTutorialSyncId)
              }
          }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Checking for class membership                                                -->
  <!-- ================================================================================ -->
  
  <dbh:method name="checkClassMembership" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a member of the class with the
      * specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String USR = "usr";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER)
        FROM
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.MEMBER) = value(userId)
        AND
        column(DbColumn.CLASS) = value(classId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isClassMember = resultSet.next();
      <dbh:log>"Done. isClassMember = " + isClassMember</dbh:log>
      return isClassMember;
    </dbh:body>
  </dbh:method>
  
  
  <!-- ================================================================================ -->
  <!-- h1: Checking for being tutor or lecturer                                         -->
  <!-- ================================================================================ -->

  <dbh:method name="checkTutorForCourse" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a tutor for the course with the
      * specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String TUT = "tut";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.TUTOR)
        FROM
        table(DbTable.TUTORIALS, TUT)
        table(DbTable.LATEST_DOC[DocType.COURSE], CRS)
        WHERE
        column(DbColumn.TUTOR, TUT) = value(userId)
        AND
        column(DbColumn.ID, CRS) = value(courseId)
        AND
        column(DbColumn.CLASS, TUT) = column(DbColumn.CLASS, CRS)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isTutor = resultSet.next();
      <dbh:log>"Done. isTutor = " + isTutor</dbh:log>
      return isTutor;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkLecturerForCourse" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a lecturer for the course with the
      * specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String LEC = "lec";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.LECTURER)
        FROM
        table(DbTable.CLASS_LECTURERS, LEC)
        table(DbTable.LATEST_DOC[DocType.COURSE], CRS)
        WHERE
        column(DbColumn.LECTURER, LEC) = value(userId)
        AND
        column(DbColumn.ID, CRS) = value(courseId)
        AND
        column(DbColumn.CLASS, LEC) = column(DbColumn.CLASS, CRS)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isLecturer = resultSet.next();
      <dbh:log>"Done. isLecturer = " + isLecturer</dbh:log>
      return isLecturer;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkTutorForClass" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a tutor for the class with the
      * specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      final String TUT = "tut";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.TUTOR)
        FROM
        table(DbTable.TUTORIALS)
        WHERE
        column(DbColumn.TUTOR) = value(userId)
        AND
        column(DbColumn.CLASS) = value(classId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isTutor = resultSet.next();
      <dbh:log>"Done. isTutor = " + isTutor</dbh:log>
      return isTutor;
    </dbh:body>
  </dbh:method>

  <dbh:method name="checkLecturerForClass" returnType="boolean">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns true if the user with the specified id is a lecturer for the class with the
      * specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.LECTURER)
        FROM
        table(DbTable.CLASS_LECTURERS)
        WHERE
        column(DbColumn.LECTURER) = value(userId)
        AND
        column(DbColumn.CLASS) = value(classId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      boolean isLecturer = resultSet.next();
      <dbh:log>"Done. isLecturer = " + isLecturer</dbh:log>
      return isLecturer;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying semester data                                                       -->
  <!-- ================================================================================ -->

  <dbh:method name="querySemesterDatum" logging="no">
    <dbh:params>
      <dbh:param type="int" name="semesterId"/>
      <dbh:param type="String" name="column"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified column for the specified semester.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocDatum(PseudoDocType.SEMESTER, semesterId, this.filterColumn(column));
    </dbh:body>
  </dbh:method>

  <dbh:method name="querySemesterData" logging="no">
    <dbh:params>
      <dbh:param type="int" name="semesterId"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns for the specified semester.
    </dbh:doc>
    <dbh:body>
      return this.queryPseudoDocData(PseudoDocType.SEMESTER, semesterId, this.filterColumns(columns));
    </dbh:body>
  </dbh:method>


  <!-- ================================================================================ -->
  <!-- h1: Storing/updating semester data                                               -->
  <!-- ================================================================================ -->

  <dbh:method name="storeSemesterData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new semester with the specified data in the database. Returns the new id.
    </dbh:doc>
    <dbh:body>
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.SEMESTERS)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            value(description)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        }
      </dbh:sqlComposer>
      <dbh:executeInsertAndReturnId/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeSemesterData" returnType="int" target="PostgreSQLDbHelper"
              toInterface="no">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="pureName"/>
      <dbh:param type="int" name="containedIn"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores a new semester with the specified data in the database. Returns the new id.
    </dbh:doc>
    <dbh:body>
      if ( pureName == null )
        throw new IllegalArgumentException("Missing pureName");
      if ( syncId == null )
        throw new IllegalArgumentException("Missing sync id");
      if ( name == null )
        throw new IllegalArgumentException("Missing name");
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.SEMESTERS)
        {
          column(DbColumn.SYNC_ID)
          column(DbColumn.PURE_NAME)
          column(DbColumn.CONTAINED_IN)
          column(DbColumn.NAME)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        }
        VALUES
        {
          value(syncId)
          value(pureName)
          value(containedIn)
          value(name)
      </dbh:sqlComposer>
      if ( description != null )
        {
          <dbh:sqlComposer>
            value(description)
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        }
      </dbh:sqlComposer>
      <dbh:pgExecuteInsertAndReturnId table="DbTable.SEMESTERS"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateSemesterData" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="syncId"/>
      <dbh:param type="String" name="name"/>
      <dbh:param type="String" name="description"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Changes the data of the semester with the specified sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/3" printParams="yes">"Started"</dbh:log>

      if ( name == null &amp;&amp; description == null )
        {
          <dbh:log number="2-3/3">"Nothing to do"</dbh:log>
          return -1;
        }

      <dbh:sqlComposer>
        UPDATE
        table(DbTable.SEMESTERS)
        SET
      </dbh:sqlComposer>

      if ( name != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.NAME) = value(name)
          </dbh:sqlComposer>
        }

      if ( description != null )
        {
          <dbh:sqlComposer>
            column(DbColumn.DESCRIPTION) = value(description)
          </dbh:sqlComposer>
        }

      <dbh:sqlComposer>
        WHERE
        column(DbColumn.SYNC_ID) = value(syncId)
      </dbh:sqlComposer>

      <dbh:executeUpdate expectedRowCount="1" withLogNumber="2/3"/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying user annotations                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="queryUserAnnotation">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="int" name="docId"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="String[]" name="columns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the specified columns from the single document user annotation table for
      * the user with the specified id, the document with the specified type and id, and
      * the specified annotation type.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        columns(columns)
        FROM
        table(this.getUserAnnsTable(docType))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.DOC) = value(docId)
        AND
        column(DbColumn.ANN_TYPE) = value(annType)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

<!-- DEPRECATED
  <dbh:method name="queryUserAnnotation">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docId1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="docId2"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="String[]" name="attribColumns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a user annotation referring to a reference of documents.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER)
        column(DbColumn.REF)
        column(DbColumn.DOC1)
        column(DbColumn.DOC2)
        column(DbColumn.ANN_TYPE)
        column(DbColumn.LAST_MODIFIED)
        column(DbColumn.CONTENT)
      </dbh:sqlComposer>
      if ( attribColumns != null )
        <dbh:sqlComposer>
          columns(attribColumns)
        </dbh:sqlComposer>
      <dbh:sqlComposer>
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.ANN_TYPE) = value(annType)
        AND
        column(DbColumn.REF) IN
          {
            SELECT
            column(DbColumn.ID)
            FROM
            table(DbTable.REF[docType1][docType2])
            WHERE
            column(DbColumn.FROM_DOC) = value(docId1)
            AND
            column(DbColumn.TO_DOC) = value(docId2)
            AND
            column(DbColumn.REF_TYPE) = value(refType)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
-->

<!-- DEPRECATED
  <dbh:method name="queryUserAnnotation" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docId1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="docId2"/>
      <dbh:param type="int" name="refType"/>
      <dbh:param type="int" name="annType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a user annotation referring to a reference of documents.
    </dbh:doc>
    <dbh:body>
      return this.queryUserAnnotation
        (userId,
        docType1, docId1,
        docType2, docId2,
        refType, annType,
        null);
    </dbh:body>
  </dbh:method>
-->

  <dbh:method name="queryUserAnnotation">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="String[]" name="attribColumns"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a user annotation referring to a reference of documents.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER)
        column(DbColumn.REF)
        column(DbColumn.DOC1)
        column(DbColumn.DOC2)
        column(DbColumn.ANN_TYPE)
        column(DbColumn.LAST_MODIFIED)
        column(DbColumn.CONTENT)
      </dbh:sqlComposer>
      if ( attribColumns != null )
        <dbh:sqlComposer>
          columns(attribColumns)
        </dbh:sqlComposer>
      <dbh:sqlComposer>
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) = value(refId)
        AND
        column(DbColumn.ANN_TYPE) = value(annType)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserAnnotation" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a user annotation referring to a reference of documents.
    </dbh:doc>
    <dbh:body>
      return this.queryUserAnnotation
        (userId,
        docType1, docType2,
        refId,
        annType,
        null);
    </dbh:body>
  </dbh:method>

  <dbh:method name="getUserAnnotationLastModified" returnType="long">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the last modification time of the specified annotation, or -1 if the annotation
      * does not exist.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.LAST_MODIFIED)
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) = value(refId)
        AND
        column(DbColumn.ANN_TYPE) = value(annType);
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      long lastModified =
        (resultSet.next()
         ? resultSet.getTimestamp(DbColumn.LAST_MODIFIED).getTime()
         : -1);
      <dbh:log>"Done. lastModified = " + lastModified</dbh:log>
      return lastModified;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Storing/updating/deleting user annotations                                   -->
  <!-- ================================================================================ -->

  <dbh:method name="storeUserAnnotation" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="String" name="content"/>
      <dbh:param type="String[]" name="attribColumns"/>
      <dbh:param type="Object[]" name="attribValues"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores <h:code>content</h:code> as the annotation by <h:code>user</h:code> to the
      * reference <h:code>refId</h:code> from <h:code>docType1</h:code> to
      * <h:code>docType2</h:code>.
    </dbh:doc>
    <dbh:body>
      this.deleteUserAnnotation(userId, docType1, docType2, refId, annType);
      <dbh:sqlComposer>
        INSERT INTO
        table(this.getUserAnnsTable(docType1, docType2))
        {
          column(DbColumn.USER)
          column(DbColumn.REF)
          column(DbColumn.DOC1)
          column(DbColumn.DOC2)
          column(DbColumn.CONTENT)
          column(DbColumn.ANN_TYPE)
      </dbh:sqlComposer>
      if ( attribColumns != null )
        <dbh:sqlComposer>
          columns(attribColumns)
        </dbh:sqlComposer>
      <dbh:sqlComposer>
        }
        SELECT
        value(userId)
        value(refId)
        column(DbColumn.FROM_DOC)
        column(DbColumn.TO_DOC)
        value(content)
        value(annType)
      </dbh:sqlComposer>
      if ( attribValues != null )
        <dbh:sqlComposer>
          values(attribValues)
        </dbh:sqlComposer>
      <dbh:sqlComposer>
        FROM
        table(DbTable.REF[docType1][docType2])
        WHERE
        column(DbColumn.ID) = value(refId)
      </dbh:sqlComposer>
      <dbh:executeUpdate expectedRowCount="1"/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeUserAnnotation" returnType="void" logging="no">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="String" name="content"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Stores <h:code>content</h:code> as the annotation by <h:code>user</h:code> to the
      * reference <h:code>ref</h:code> from <h:code>docType1</h:code> to
      * <h:code>docType2</h:code>.
    </dbh:doc>
    <dbh:body>
    this.storeUserAnnotation
      (userId,
       docType1, docType2,
       refId,
       annType,
       content,
       null,
       null);
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateUserAnnotation" returnType="void">
    <dbh:params>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="newDocId"/>
      <dbh:param type="int" name="oldDocId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * <h:p>
      *   Updates the {@link DbColumn#REF REF} column of a user annotation table.
      * </h:p>
      * <h:p>
      *   The annotation table is specified by <h:code>docType1</h:code> and
      *   <h:code>doctype2</h:code>: it is the table that stores user annotations on references
      *   from documents of type <h:code>docType1</h:code> to documents of type
      *   <h:code>doctype2</h:code>.
      * </h:p>
      * <h:p>
      *   <h:code>newDocId</h:code> and <h:code>oldDocId</h:code> specify a new and an old
      *   version of a document of type <h:code>docType1</h:code>. All {@link DbColumn#REF REF}
      *   entries of annotations on references starting from <h:code>oldDocId</h:code> are
      *   updated to the corresponding references starting from <h:code>newDocId</h:code>. Two
      *   references correspond to each other if they have the same local id. 
      * </h:p>
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>

      // Get refs with same lids:
      ResultSet resultSet = this.queryRefsWithSameLids(docType1, docType2, newDocId, oldDocId);

      // Compose update statement:
      <dbh:sqlComposer>
        UPDATE
        table(this.getUserAnnsTable(docType1, docType2))
        SET
        column(DbColumn.REF) = ?
        WHERE
        column(DbColumn.REF) = ?
      </dbh:sqlComposer>
      String updateCmd = this.sqlComposer.getCode();
      <dbh:log>"updateCmd = " + updateCmd</dbh:log>
      PreparedStatement statement = this.connection.prepareStatement(updateCmd);

      // Update ref ids:
      int count = 0;
      while ( resultSet.next() )
        {
          count++;
          String lid = resultSet.getString(DbColumn.LID);
          int newRefId = resultSet.getInt("new_id");
          int oldRefId = resultSet.getInt("old_id");
          int newRefType = resultSet.getInt("new_ref_type");
          int oldRefType = resultSet.getInt("old_ref_type");
          <dbh:log number='3." + count + "/4'>
             " lid = " + lid +
             ", newRefId = " + newRefId +
             ", oldRefId = " + oldRefId +
             ", newRefType = " + newRefType +
             ", oldRefType = " + oldRefType
          </dbh:log>
          if ( newRefType != oldRefType )
            throw new SQLException
              ("Error while updating annotation for lid: " + lid +
               ". Ref types does not coincide: old: " + oldRefType +
               ", new: " + newRefType);
          statement.setInt(1, newRefId);
          statement.setInt(2, oldRefId);
          statement.executeUpdate();
        }
      statement.close();

      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="deleteUserAnnotation" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="annType"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Deletes the user annotation for the specified user, document types, reference, and
      * annotation type.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        DELETE
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) = value(refId)
        AND
        column(DbColumn.ANN_TYPE) = value(annType)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="deleteUserAnnotation" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int[]" name="annTypes"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Deletes the user annotation for the specified user, document types, reference, and
      * annotation types. If <h:code>annTypes</h:code> is <h:code>null</h:code> or empty,
      * annotations of any type will be deleted.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        DELETE
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) = value(refId)
      </dbh:sqlComposer>
      if ( annTypes != null &amp;&amp; annTypes.length &gt; 0 )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.ANN_TYPE) IN { values(annTypes) }
          </dbh:sqlComposer>
        }
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="deleteUserAnnotationsByRefOrigin" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
      <dbh:param type="int" name="refOriginId"/>
      <dbh:param type="int[]" name="annTypes"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Delets the user annotations for the specified user, document types, reference origin, and
      * annotation types.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        DELETE
        FROM
        table(this.getUserAnnsTable(docType1, docType2))
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) IN
        {
          SELECT
          column(DbColumn.ID)
          FROM
          table(DbTable.REF[docType1][docType2])
          WHERE
          column(DbColumn.FROM_DOC) = value(refOriginId)
        }
      </dbh:sqlComposer>
      if ( annTypes != null &amp;&amp; annTypes.length &gt; 0 )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.ANN_TYPE) IN { values(annTypes) }
          </dbh:sqlComposer>
        }
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="changeUserOfUserAnnotations" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="oldUserId"/>
      <dbh:param type="int" name="newUserId"/>
      <dbh:param type="int" name="docType1"/>
      <dbh:param type="int" name="docType2"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Changes the user of all annotations fromw the specified old to the specified new user.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        UPDATE
        table(this.getUserAnnsTable(docType1, docType2))
        SET column(DbColumn.USER) = value(newUserId)
        WHERE
        column(DbColumn.USER) = value(oldUserId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: List of (pseudo-)documents of different kinds                                -->
  <!-- ================================================================================ -->

  <dbh:method name="queryClassesAndCourses">
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a list containing all e-learning classes and all (latest) courses.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
        column("*")
        FROM
        table(DbTable.CLASSES_AND_COURSES)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryCoursesAndTutorialsForClass">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns a list of all courses and tutorials for the specified class.
    </dbh:doc>
    <dbh:body>
      final String coursesTable = DbTable.LATEST_DOC[DocType.COURSE];
      final String tutorialsTable = DbTable.TUTORIALS_EXT;
      final String usersTable = DbTable.USERS;
      <dbh:sqlComposer>
        SELECT
        value(DocType.nameFor(DocType.COURSE)) AS column(DbColumn.DOC_TYPE)
        column(DbColumn.ID, coursesTable)
        column(DbColumn.NAME, coursesTable)
        columnNull AS column(DbColumn.TUTOR_ID)
        columnNull AS column(DbColumn.TUTOR_FIRST_NAME)
        columnNull AS column(DbColumn.TUTOR_SURNAME)
        columnNull AS column(DbColumn.CAPACITY)
        columnNull AS column(DbColumn.OCCUPANCY)
        FROM table(coursesTable)
        WHERE
        column(DbColumn.CLASS, coursesTable) = value(classId)
        UNION
        SELECT
        value(PseudoDocType.nameFor(PseudoDocType.TUTORIAL)) AS column(DbColumn.DOC_TYPE)
        column(DbColumn.ID, tutorialsTable)
        column(DbColumn.NAME, tutorialsTable)
        column(DbColumn.ID, usersTable) AS column(DbColumn.TUTOR_ID)
        column(DbColumn.FIRST_NAME, usersTable) AS column(DbColumn.TUTOR_FIRST_NAME)
        column(DbColumn.SURNAME, usersTable) AS column(DbColumn.TUTOR_SURNAME)
        column(DbColumn.CAPACITY, tutorialsTable)
        column(DbColumn.OCCUPANCY, tutorialsTable)
        FROM
        table(tutorialsTable)
        table(usersTable)
        WHERE
        column(DbColumn.ID, usersTable) = column(DbColumn.TUTOR, tutorialsTable)
        AND
        column(DbColumn.CLASS, tutorialsTable) = value(classId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryClassMembers">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      Returns all students, their tutorials, and their tutors, for the e-learning class
      with the specified id. The columns of the returned result set are:
      <h:ol>
        <h:li>{@link DbColumn.ID ID} (of the student)</h:li>
        <h:li>{@link DbColumn.FIRST_NAME FIRST_NAME} (of the student)</h:li>
        <h:li>{@link DbColumn.SURNAME SURNAME} (of the student)</h:li>
        <h:li>{@link DbColumn.TUTORIAL_ID TUTORIAL_ID}</h:li>
        <h:li>{@link DbColumn.TUTORIAL_NAMW TUTORIAL_NAME}</h:li>
        <h:li>{@link DbColumn.TUTOR_ID TUTOR_ID}</h:li>
        <h:li>{@link DbColumn.TUTOR_FIRST_NAME TUTOR_FIRST_NAME}</h:li>
        <h:li>{@link DbColumn.TUTOR_SURNAME TUTOR_SURNAME}</h:li>
      </h:ol>
    </dbh:doc>
    <dbh:body>
      final String STUDENTS = "students";
      final String TUTORS = "tutors";
      final String TUTORIALS = DbTable.TUTORIALS;
      final String TUTORIAL_MEMBERS = DbTable.TUTORIAL_MEMBERS;
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, STUDENTS)
        column(DbColumn.FIRST_NAME, STUDENTS)
        column(DbColumn.SURNAME, STUDENTS)
        column(DbColumn.ID, TUTORIALS) AS column(DbColumn.TUTORIAL_ID)
        column(DbColumn.NAME, TUTORIALS) AS column(DbColumn.TUTORIAL_NAME)
        column(DbColumn.ID, TUTORS) AS column(DbColumn.TUTOR_ID)
        column(DbColumn.FIRST_NAME, TUTORS) AS column(DbColumn.TUTOR_FIRST_NAME)
        column(DbColumn.SURNAME, TUTORS) AS column(DbColumn.TUTOR_SURNAME)
        FROM
        table(DbTable.USERS) AS table(STUDENTS)
        table(TUTORIALS)
        table(DbTable.USERS) AS table(TUTORS)
        table(DbTable.TUTORIAL_MEMBERS)
        WHERE
        column(DbColumn.CLASS, TUTORIAL_MEMBERS) = value(classId)
        AND
        column(DbColumn.ID, STUDENTS) = column(DbColumn.MEMBER, TUTORIAL_MEMBERS)
        AND
        column(DbColumn.ID, TUTORIALS) = column(DbColumn.TUTORIAL, TUTORIAL_MEMBERS)
        AND
        column(DbColumn.ID, TUTORS) = column(DbColumn.TUTOR, TUTORIALS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying / storing grades                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="queryUserWorksheetGrades">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * <h:p>
      *   Returns the results the specified user achieved in the problems of the specified
      *   worksheet. The returned table has a structure as shown in the following example:
      *   <h:pre>&lt;!--
        --&gt;   wks_id | ref | prb_id | label | points | category | ann_type | score
&lt;!-- --&gt;  --------+-----+--------+-------+--------+----------+----------+-------
&lt;!-- --&gt;       32 |  63 |    412 |     1 |      6 |       21 |          |
&lt;!-- --&gt;       32 |  64 |    419 |     4 |      6 |       16 |          |
&lt;!-- --&gt;       32 |  65 |    418 |     5 |      6 |       17 |          |
&lt;!-- --&gt;       32 |  66 |    417 |     3 |      6 |       16 |          |
&lt;!-- --&gt;       32 |  67 |    416 |     2 |      6 |       17 |        1 |
&lt;!-- --&gt;       32 |  68 |    415 |     6 |      6 |       16 |        1 |
&lt;!-- --&gt;       32 |  69 |    414 |     7 |      6 |       16 |        1 |
&lt;!-- --&gt;       32 |  70 |    413 |     8 |      6 |       16 |        1 |
&lt;!-- --&gt;       32 |  70 |    413 |     9 |      6 |       16 |        2 |   0.4
&lt;!-- --&gt;       32 |  71 |    411 |    10 |      6 |       16 |          |
&lt;!-- --&gt;</h:pre>
      *   The columns have the following meanings (from left to right): the worksheet id, the
      *   id of the worksheet - generic problem reference, the generic problem id, the label of
      *   the generic problem, the maximum number of points for the generic problem, the category
      *   of the generic problem, the annotiation type of the user annotation, the user score.
      * </h:p>
      * <h:p>
      *   For each problem, one of the following cases may occur:
      *   <h:ul>
      *     <h:li>The user has saved answers, and the answers have been corrected. In this
      *       case, a score exists.</h:li>
      *     <h:li>The user has saved answers, but the answers have not been corrected yet.</h:li>
      *     <h:li>The user has not saved answers</h:li>
      *   </h:ul>
      * </h:p>
      * <h:p>
      *   In the first case, the above table contains two rows for the problem, one with
      *   annotation type {@link AnnType#PROBLEM_ANSWERS PROBLEM_ANSWERS} and one with
      *   annotation type {@link AnnType#PROBLEM_CORRECTION PROBLEM_CORRECTION}. The latter
      *   one has a non-NULL entry in the score column.
      *   In the second case, the table contains one row for the problem. Its annotation type
      *   column is {@link AnnType#PROBLEM_ANSWERS PROBLEM_ANSWERS}.
      *   In the third case, the table contains one row for the problem, too. Its annotation
      *   type column is NULL.
      * </h:p>
     </dbh:doc>
    <dbh:body>
      final String PRB = "prb";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column("*", PRB)
        column(DbColumn.ANN_TYPE, ANN)
        column(DbColumn.SCORE, ANN)
        FROM
        table(DbTable.ASSIGNED_PROBLEMS, PRB)
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        {
          column(DbColumn.REF, PRB) = column(DbColumn.REF, ANN)
          AND
          column(DbColumn.ANN_TYPE, ANN) IN
          {
            value(AnnType.PROBLEM_ANSWERS)
            value(AnnType.PROBLEM_CORRECTION)
          }
          AND
          column(DbColumn.USER) = value(userId)
        }
        WHERE
        column(DbColumn.WORKSHEET_ID) = value(worksheetId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetUserProblemGrades">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Retruns the grades per problem for the specified user and worksheet. The returned result
      * set contains the following columns:
      * <h:ul>
      *   <h:li>{@link DbColumn#USER_ID}</h:li>
      *   <h:li>{@link DbColumn#USER_FIRST_NAME}</h:li>
      *   <h:li>{@link DbColumn#USER_SURNAME}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_ID}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_VC_THREAD_ID}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_LABEL}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_CATEGORY_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_REF_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_LABEL}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_CATEGORY_ID}</h:li>
      *   <h:li>{@link DbColumn#POINTS}</h:li>
      *   <h:li>{@link DbColumn#ANN_TYPE}</h:li>
      *   <h:li>{@link DbColumn#SCORE}</h:li>
      * </h:ul>
     </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String ANN = "ann";
      final String PRB_CTX = "prb_ctx";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.WORKSHEET_VC_THREAD_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_VC_THREAD_ID)
        column(DbColumn.WORKSHEET_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.PROBLEM_ID, PRB_CTX) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) AS column(DbColumn.PROBLEM_CATEGORY_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.ANN_TYPE, ANN) AS column(DbColumn.ANN_TYPE)
        column(DbColumn.SCORE, ANN) AS column(DbColumn.SCORE)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        {
          column(DbColumn.WORKSHEET_ID, PRB_CTX) = value(worksheetId)
          AND
          column(DbColumn.ID, USR) = value(userId)
        }
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        {
          column(DbColumn.ANN_TYPE, ANN) IN
          {
            value(AnnType.PROBLEM_ANSWERS)
            value(AnnType.PROBLEM_CORRECTION)
          }
          AND
          column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
          AND
          column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
        }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryTutorialUserProblemGrades">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String TUT_MEM = "tut_mem";
      final String PRB_CTX = "prb_ctx";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.WORKSHEET_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.TIMEFRAME_START, PRB_CTX) AS column(DbColumn.TIMEFRAME_START)
        column(DbColumn.TIMEFRAME_END, PRB_CTX) AS column(DbColumn.TIMEFRAME_END)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.PROBLEM_ID, PRB_CTX) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) AS column(DbColumn.PROBLEM_CATEGORY_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.ANN_TYPE, ANN) AS column(DbColumn.ANN_TYPE)
        column(DbColumn.SCORE, ANN) AS column(DbColumn.SCORE)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.TUTORIAL_MEMBERS, TUT_MEM)
        ON
        column(DbColumn.MEMBER, TUT_MEM) = column(DbColumn.ID, USR)
        AND
        column(DbColumn.TUTORIAL) = value(tutorialId)
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        column(DbColumn.CLASS_ID, PRB_CTX) = column(DbColumn.CLASS, TUT_MEM)
        AND
        column(DbColumn.COURSE_ID, PRB_CTX) = value(courseId)
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        {
          column(DbColumn.ANN_TYPE, ANN) IN
          {
            value(AnnType.PROBLEM_ANSWERS)
            value(AnnType.PROBLEM_CORRECTION)
          }
          AND
          column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
          AND
          column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
        }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserProblemGrades">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String ANN = "ann";
      final String PRB_CTX = "prb_ctx";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.WORKSHEET_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.PROBLEM_ID, PRB_CTX) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) AS column(DbColumn.PROBLEM_CATEGORY_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.ANN_TYPE, ANN) AS column(DbColumn.ANN_TYPE)
        column(DbColumn.SCORE, ANN) AS column(DbColumn.SCORE)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        {
          column(DbColumn.COURSE_ID, PRB_CTX) = value(courseId)
          AND
          column(DbColumn.ID, USR) = value(userId)
        }
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        {
          column(DbColumn.ANN_TYPE, ANN) IN
          {
            value(AnnType.PROBLEM_ANSWERS)
            value(AnnType.PROBLEM_CORRECTION)
          }
          AND
          column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
          AND
          column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
        }
      </dbh:sqlComposer>
     <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryGradesForClass">
    <dbh:params>
      <dbh:param type="int" name="classId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the grades per problem for all users of the specified class. The result
      * set contains the following columns:
      * <h:ul>
      *   <h:li>{@link DbColumn#USER_ID USER_ID}</h:li>
      *   <h:li>{@link DbColumn#USER_FIRST_NAME USER_FIRST_NAME}</h:li>
      *   <h:li>{@link DbColumn#USER_SURNAME USER_SURNAME}</h:li>
      *   <h:li>{@link DbColumn#USER_SYNC_ID USER_SYNC_ID}</h:li>
      *   <h:li>{@link DbColumn#COURSE_ID COURSE_ID}</h:li>
      *   <h:li>{@link DbColumn#COURSE_NAME COURSE_NAME}</h:li>
      *   <h:li>{@link DbColumn#COURSE_VC_THREAD COURSE_VC_THREAD}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_ID WORKSHEET_ID}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_LABEL WORKSHEET_LABEL}</h:li>
      *   <h:li>{@link DbColumn#WORKSHEET_CATEGORY_ID WORKSHEET_CATEGORY_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_REF_ID PROBLEM_REF_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_ID PROBLEM_ID}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_LABEL PROBLEM_LABEL}</h:li>
      *   <h:li>{@link DbColumn#PROBLEM_CATEGORY_ID PROBLEM_CATEGORY_ID}</h:li>
      *   <h:li>{@link DbColumn#POINTS POINTS}</h:li>
      *   <h:li>{@link DbColumn#ANN_TYPE ANN_TYPE}</h:li>
      *   <h:li>{@link DbColumn#SCORE SCORE}</h:li>
      * </h:ul>
    </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String ANN = "ann";
      final String PRB_CTX = "prb_ctx";
      final String TUT_MEM = "tut_mem";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.SYNC_ID, USR) AS column(DbColumn.USER_SYNC_ID)
        column(DbColumn.COURSE_ID, PRB_CTX) AS column(DbColumn.COURSE_ID)
        column(DbColumn.COURSE_NAME, PRB_CTX) AS column(DbColumn.COURSE_NAME)
        column(DbColumn.COURSE_VC_THREAD_ID, PRB_CTX) AS column(DbColumn.COURSE_VC_THREAD_ID)
        column(DbColumn.WORKSHEET_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.PROBLEM_ID, PRB_CTX) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) AS column(DbColumn.PROBLEM_CATEGORY_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.ANN_TYPE, ANN) AS column(DbColumn.ANN_TYPE)
        column(DbColumn.SCORE, ANN) AS column(DbColumn.SCORE)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.TUTORIAL_MEMBERS, TUT_MEM)
        ON
        column(DbColumn.MEMBER, TUT_MEM) = column(DbColumn.ID, USR)
        AND
        column(DbColumn.CLASS) = value(classId)
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        column(DbColumn.CLASS_ID, PRB_CTX) = value(classId)
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
        AND
        column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
      </dbh:sqlComposer>
     <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryTotalCourseGrades">
    <dbh:params>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String CRS_MEM = "crs_mem";
      final String ANN = "ann";
      final String PRB_CTX = "prb_ctx";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.SYNC_ID, USR) AS column(DbColumn.SYNC_ID)
        column(DbColumn.WORKSHEET_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.PROBLEM_ID, PRB_CTX) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) AS column(DbColumn.PROBLEM_CATEGORY_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.ANN_TYPE, ANN) AS column(DbColumn.ANN_TYPE)
        column(DbColumn.SCORE, ANN) AS column(DbColumn.SCORE)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.COURSE_MEMBERS, CRS_MEM)
        ON
        {
          column(DbColumn.DOCUMENT, CRS_MEM) = value(courseId)
          AND
          column(DbColumn.MEMBER, CRS_MEM) = column(DbColumn.ID, USR)
        }
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        {
          column(DbColumn.COURSE_ID, PRB_CTX) = value(courseId)
        }
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        {
          column(DbColumn.ANN_TYPE, ANN) IN
          {
            value(AnnType.PROBLEM_ANSWERS)
            value(AnnType.PROBLEM_CORRECTION)
          }
          AND
          column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
          AND
          column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
        }
      </dbh:sqlComposer>
     <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
  
  <dbh:method name="queryUserCourseGrades">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="courseId"/>
      <dbh:param type="int[]" name="problemCategories"/>
      <dbh:param type="int[]" name="worksheetCategories"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String REF_CRS_WKS = "ref_crs_wks";
      final String WKS = "wks";
      final String REF_WKS_PRB = "ref_wks_prb";
      final String PRB = "prb";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, REF_CRS_WKS) AS column(DbColumn.REF_ID)
        column(DbColumn.ID, WKS) AS column(DbColumn.ID)
        column(DbColumn.LABEL, REF_CRS_WKS) AS column(DbColumn.LABEL)
        column(DbColumn.CATEGORY, WKS) AS column(DbColumn.CATEGORY)
        sum { column(DbColumn.POINTS, REF_WKS_PRB) } AS column(DbColumn.POINTS)
        sum { column(DbColumn.SCORE, ANN) * column(DbColumn.POINTS, REF_WKS_PRB) } AS column(DbColumn.RESULT)
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS)
        JOIN table(DbTable.DOC[DocType.WORKSHEET], WKS)
        ON column(DbColumn.TO_DOC, REF_CRS_WKS) = column(DbColumn.ID, WKS)
      </dbh:sqlComposer>
      if ( worksheetCategories != null )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.CATEGORY, WKS) IN { values(worksheetCategories) }
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        JOIN table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF_WKS_PRB)
        ON column(DbColumn.FROM_DOC, REF_WKS_PRB) = column(DbColumn.TO_DOC, REF_CRS_WKS)
        JOIN table(DbTable.DOC[DocType.GENERIC_PROBLEM]) AS table(PRB)
        ON column(DbColumn.TO_DOC, REF_WKS_PRB) = column(DbColumn.ID, PRB)
      </dbh:sqlComposer>
      if ( problemCategories != null )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.CATEGORY, PRB) IN { values(problemCategories) }
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        LEFT JOIN table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON column(DbColumn.REF, ANN) = column(DbColumn.ID, REF_WKS_PRB)
        AND
        column(DbColumn.USER, ANN) = value(userId)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_CORRECTION)
        WHERE
        column(DbColumn.FROM_DOC, REF_CRS_WKS) = value(courseId)
        GROUP BY
          column(DbColumn.REF_ID)
          column(DbColumn.ID, WKS)
          column(DbColumn.CATEGORY, WKS)
          column(DbColumn.LABEL, REF_CRS_WKS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!--
  <dbh:method name="queryTutorialCourseGrades">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="courseId"/>
      <dbh:param type="int[]" name="problemCategories"/>
      <dbh:param type="int[]" name="worksheetCategories"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String TUT_MEM = "tut_mem";
      final String USR = "usr";
      final String WKS = "wks";
      final String PRB = "prb";
      final String REF_CRS_WKS = "ref_crs_wks";
      final String REF_WKS_PRB = "ref_wks_prb";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.MEMBER, TUT_MEM) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.CATEGORY, WKS) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.TO_DOC, REF_CRS_WKS) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.LABEL, REF_CRS_WKS) AS column(DbColumn.WORKSHEET_LABEL)
        sum { column(DbColumn.POINTS, REF_WKS_PRB) } AS column(DbColumn.POINTS)
        sum { column(DbColumn.SCORE, ANN) * column(DbColumn.POINTS, REF_WKS_PRB) }
          AS column(DbColumn.RESULT)
        FROM
        {
        table(DbTable.TUTORIAL_MEMBERS, TUT_MEM)
        JOIN
        table(DbTable.USERS, USR)
        ON
        column(DbColumn.MEMBER, TUT_MEM) = column(DbColumn.ID, USR)
        JOIN
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS)
        ON
        { TRUE }
        JOIN
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF_WKS_PRB)
        ON
        column(DbColumn.FROM_DOC, REF_WKS_PRB) = column(DbColumn.TO_DOC, REF_CRS_WKS)
        JOIN
        table(DbTable.DOC[DocType.WORKSHEET], WKS)
        ON
        column(DbColumn.ID, WKS) = column(DbColumn.TO_DOC, REF_CRS_WKS)
      </dbh:sqlComposer>
      if ( worksheetCategories != null )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.CATEGORY, WKS) IN { values(worksheetCategories) }
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        JOIN
        table(DbTable.DOC[DocType.GENERIC_PROBLEM], PRB)
        ON
        column(DbColumn.ID, PRB) = column(DbColumn.TO_DOC, REF_WKS_PRB)
      </dbh:sqlComposer>
      if ( problemCategories != null )
        {
          <dbh:sqlComposer>
            AND
            column(DbColumn.CATEGORY, PRB) IN { values(problemCategories) }
          </dbh:sqlComposer>
        }
      <dbh:sqlComposer>
        }
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        column(DbColumn.REF, ANN) = column(DbColumn.ID, REF_WKS_PRB)
        AND
        column(DbColumn.USER, ANN) = column(DbColumn.MEMBER, TUT_MEM)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_CORRECTION)
        WHERE
        column(DbColumn.FROM_DOC, REF_CRS_WKS) = value(courseId)
        AND
        column(DbColumn.TUTORIAL, TUT_MEM) = value(tutorialId)
        GROUP BY
        column(DbColumn.MEMBER, TUT_MEM)
        column(DbColumn.FIRST_NAME, USR)
        column(DbColumn.SURNAME, USR)
        column(DbColumn.CATEGORY, WKS)
        column(DbColumn.TO_DOC, REF_CRS_WKS)
        column(DbColumn.LABEL, REF_CRS_WKS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
  -->

  <!-- Similar to queryTutorialUserProblemGrades, both methods should perhaps be merged -->
  <dbh:method name="queryTutorialUserTraditionalProblemGrades">
    <dbh:params>
      <dbh:param type="int" name="tutorialId"/>
      <dbh:param type="int" name="courseId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String TUT_MEM = "tut_mem";
      final String PRB_CTX = "prb_ctx";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, USR) AS column(DbColumn.USER_ID)
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.WORKSHEET_ID, PRB_CTX)
        column(DbColumn.WORKSHEET_LABEL, PRB_CTX)
        column(DbColumn.WORKSHEET_CATEGORY_ID, PRB_CTX)
        column(DbColumn.PROBLEM_ID, PRB_CTX)
        column(DbColumn.PROBLEM_LABEL, PRB_CTX)
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX)
        column(DbColumn.REF_ID, PRB_CTX) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.POINTS, PRB_CTX)
        column(DbColumn.SCORE, ANN)
        FROM
        table(DbTable.USERS, USR)
        JOIN
        table(DbTable.TUTORIAL_MEMBERS, TUT_MEM)
        ON
        column(DbColumn.MEMBER, TUT_MEM) = column(DbColumn.ID, USR)
        AND
        column(DbColumn.TUTORIAL, TUT_MEM) = value(tutorialId)
        JOIN
        table(DbTable.PROBLEM_CONTEXT, PRB_CTX)
        ON
        column(DbColumn.COURSE_ID, PRB_CTX) = value(courseId)
        AND
        column(DbColumn.PROBLEM_CATEGORY_ID, PRB_CTX) = value(Category.TRADITIONAL)
        LEFT OUTER JOIN
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        ON
        column(DbColumn.REF, ANN) = column(DbColumn.REF_ID, PRB_CTX)
        AND
        column(DbColumn.USER, ANN) = column(DbColumn.ID, USR)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_CORRECTION)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeProblemGrade" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="float" name="score"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:log number="1/4" printParams="yes">"Started"</dbh:log>
      String annsTable = this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM);

      <!-- Check if entry exists: -->
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.USER)
        FROM 
        table(annsTable)
        WHERE
        column(DbColumn.USER) = value(userId)
        AND
        column(DbColumn.REF) = value(refId)
        AND
        column(DbColumn.ANN_TYPE) = value(AnnType.PROBLEM_CORRECTION);
      </dbh:sqlComposer>
      String testQuery = this.sqlComposer.getCode();
      <dbh:log number="2/4">"testQuery = " + testQuery</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(testQuery);

      if ( resultSet.next() )
        {
          <!-- Entry exists: -->
          <dbh:sqlComposer clear="yes">
            UPDATE
            table(annsTable)
            SET column(DbColumn.SCORE) = value(score)
            WHERE
            column(DbColumn.USER) = value(userId)
            AND
            column(DbColumn.REF) = value(refId)
            AND
            column(DbColumn.ANN_TYPE) = value(AnnType.PROBLEM_CORRECTION);
          </dbh:sqlComposer>
          <dbh:executeUpdate writeLogNumber="3/4"/>
        }
      else
        {
          <!-- Entry does not exist: -->
          <dbh:sqlComposer clear="yes">
            INSERT INTO
            table(annsTable)
            {
              column(DbColumn.USER)
              column(DbColumn.REF)
              column(DbColumn.ANN_TYPE)
              column(DbColumn.SCORE)
            }
            VALUES
            {
              value(userId)
              value(refId)
              value(AnnType.PROBLEM_CORRECTION)
              value(score)
            }
          </dbh:sqlComposer>
          <dbh:executeUpdate/>
        }
    </dbh:body>
  </dbh:method>

  <!--
  <dbh:method name="queryUserWorksheetGrade">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String PRB = "prb";
      final String GRD = "grd";
      final String PRB_S = "prb_s";
      final String ANN_S = "ann_s";
      final String annsTable = this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM);
      <dbh:sqlComposer>
        SELECT DISTINCT
          column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
          column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
          column(DbColumn.SYNC_ID, USR) AS column(DbColumn.USER_SYNC_ID)
          column(DbColumn.WORKSHEET_VC_THREAD_ID, PRB)
          column(DbColumn.WORKSHEET_LABEL, PRB)
          column(DbColumn.WORKSHEET_CATEGORY_ID, PRB)
          column(DbColumn.COURSE_ID, PRB)
          column(DbColumn.COURSE_VC_THREAD_ID, PRB)
          column(DbColumn.CLASS_ID, PRB)
          column(DbColumn.POINTS, GRD)
          column(DbColumn.RESULT, GRD)
        FROM
          table(DbTable.USERS, USR)
          table(DbTable.PROBLEM_CONTEXT, PRB),
          {
            SELECT
              sum { column(DbColumn.POINTS, PRB_S) } AS column(DbColumn.POINTS)
              sum { CAST { column(DbColumn.POINTS, PRB_S) AS type("double precision") }
                    * CAST { column(DbColumn.SCORE, ANN_S) AS type("double precision") } }
                AS column(DbColumn.RESULT)
            FROM
              table(DbTable.PROBLEM_CONTEXT, PRB_S)
            LEFT OUTER JOIN
              table(annsTable, ANN_S)
            ON
              {
                  column(DbColumn.REF_ID, PRB_S) = column(DbColumn.REF, ANN_S)
                AND
                  column(DbColumn.ANN_TYPE, ANN_S) = value(AnnType.PROBLEM_CORRECTION)
                AND
                  column(DbColumn.USER, ANN_S) = value(userId)
              }
            WHERE
              column(DbColumn.WORKSHEET_ID, PRB_S) = value(worksheetId)
          } AS table(GRD)
        WHERE
          column(DbColumn.ID, USR) = value(userId)
        AND
          column(DbColumn.WORKSHEET_ID, PRB) = value(worksheetId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>
  -->

  <dbh:method name="queryUserWorksheetGrade">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
          *
        FROM
          table(DbTable.USER_WORKSHEET_GRADES)
        WHERE
          column(DbColumn.USER_ID) = value(userId)
        AND
          column(DbColumn.WORKSHEET_ID) = value(worksheetId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetContext">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
          *
        FROM
          table(DbTable.WORKSHEET_CONTEXT)
        WHERE
          column(DbColumn.ID) = value(worksheetId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetContext">
    <dbh:params>
      <dbh:param type="int[]" name="worksheetIds"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT
          *
        FROM
          table(DbTable.WORKSHEET_CONTEXT)
        WHERE
          column(DbColumn.ID) IN { values(worksheetIds) }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryUserProblemDataIndex">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
     </dbh:doc>
    <dbh:body>
      final String REF_CRS_WKS = "ref_crs_wks";
      final String REF_WKS_PRB = "ref_wks_prb";
      final String ANN = "ann";
      String courseTable = this.getTableName(DocType.COURSE, true);
      String annsTable = this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM);
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID, courseTable) AS column(DbColumn.COURSE_ID)
        column(DbColumn.NAME, courseTable) AS column(DbColumn.COURSE_NAME)
        column(DbColumn.TO_DOC, REF_CRS_WKS) AS column(DbColumn.WORKSHEET_ID)
        column(DbColumn.LABEL, REF_CRS_WKS) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.TO_DOC, REF_WKS_PRB) AS column(DbColumn.PROBLEM_ID)
        column(DbColumn.LABEL, REF_WKS_PRB) AS column(DbColumn.PROBLEM_LABEL)
        column(DbColumn.ANN_TYPE, ANN)
        column(DbColumn.LAST_MODIFIED, ANN)
        column(DbColumn.SCORE, ANN)
        FROM
        table(annsTable, ANN)
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF_WKS_PRB)
        table(courseTable)
        WHERE
        column(DbColumn.USER, ANN) = value(userId)
        AND
        column(DbColumn.ID, REF_WKS_PRB) = column(DbColumn.REF, ANN)
        AND
        column(DbColumn.TO_DOC, REF_CRS_WKS) = column(DbColumn.FROM_DOC, REF_WKS_PRB)
        AND
        column(DbColumn.ID, courseTable) = column(DbColumn.FROM_DOC, REF_CRS_WKS)
        }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>






  <!-- ================================================================================ -->
  <!-- h1: Querying input data for bulk correction                                      -->
  <!-- ================================================================================ -->

  <dbh:method name="queryWorksheetBulkCorrectionInputData">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      Queries the input data for a bulk correction for all users and the specified worksheet.
      The returned result set has the following columns:
      <h:ol>
        <h:li>{@link DbColumn#PROBLEM_REF_ID PROBLEM_REF_ID} (id of the
          worksheet/generic_probelm reference)</h:li>
        <h:li>{@link DbColumn#USER_ID USER_ID}</h:li>
        <h:li>{@link DbColumn#PROBLEM_ID PROBLEM_ID} (id of the generic problem)</h:li>
      </h:ol>
    </dbh:doc>
    <dbh:body>
      final String ANN = "ann";
      final String REF = "ref";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.REF, ANN) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.USER, ANN) AS column(DbColumn.USER_ID)
        column(DbColumn.TO_DOC, REF) AS column(DbColumn.PROBLEM_ID)
        FROM
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF)
        WHERE
        column(DbColumn.ID, REF) = column(DbColumn.REF, ANN)
        AND
        column(DbColumn.FROM_DOC, REF) = value(worksheetId)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_ANSWERS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetUserBulkCorrectionInputData">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      Queries the input data for a bulk correction for the specified user and worksheet.
      The returned result set has the following colums:
      <h:ol>
        <h:li>{@link DbColumn#PROBLEM_REF_ID PROBLEM_REF_ID} (id of the
          worksheet/generic_probelm reference)</h:li>
        <h:li>{@link DbColumn#USER_ID USER_ID}</h:li>
        <h:li>{@link DbColumn#PROBLEM_ID PROBLEM_ID} (id of the generic problem)</h:li>
      </h:ol>
    </dbh:doc>
    <dbh:body>
      final String ANN = "ann";
      final String REF = "ref";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.REF, ANN) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.USER, ANN) AS column(DbColumn.USER_ID)
        column(DbColumn.TO_DOC, REF) AS column(DbColumn.PROBLEM_ID)
        FROM
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF)
        WHERE
        column(DbColumn.ID, REF) = column(DbColumn.REF, ANN)
        AND
        column(DbColumn.FROM_DOC, REF) = value(worksheetId)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_ANSWERS)
        AND
        column(DbColumn.USER, ANN) = value(userId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetTutorialBulkCorrectionInputData">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="tutorialId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      Queries the input data for a bulk correction for the specified tutorial and worksheet.
      The returned result set has the following colums:
      <h:ol>
        <h:li>{@link DbColumn#PROBLEM_REF_ID PROBLEM_REF_ID} (id of the
          worksheet/generic_probelm reference)</h:li>
        <h:li>{@link DbColumn#USER_ID USER_ID}</h:li>
        <h:li>{@link DbColumn#PROBLEM_ID PROBLEM_ID} (id of the generic problem)</h:li>
      </h:ol>
    </dbh:doc>
    <dbh:body>
      final String ANN = "ann";
      final String REF = "ref";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.REF, ANN) AS column(DbColumn.PROBLEM_REF_ID)
        column(DbColumn.USER, ANN) AS column(DbColumn.USER_ID)
        column(DbColumn.TO_DOC, REF) AS column(DbColumn.PROBLEM_ID)
        FROM
        table(this.getUserAnnsTable(DocType.WORKSHEET, DocType.GENERIC_PROBLEM), ANN)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF)
        WHERE
        column(DbColumn.ID, REF) = column(DbColumn.REF, ANN)
        AND
        column(DbColumn.FROM_DOC, REF) = value(worksheetId)
        AND
        column(DbColumn.ANN_TYPE, ANN) = value(AnnType.PROBLEM_ANSWERS)
        AND
        column(DbColumn.USER, ANN) IN
          {
            SELECT column(DbColumn.MEMBER)
            FROM
            table(DbTable.TUTORIAL_MEMBERS)
            WHERE
            column(DbColumn.TUTORIAL) = value(tutorialId)
          }
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying/updating special data                                               -->
  <!-- ================================================================================ -->

  <dbh:method name="queryWorksheetData">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the (latest) course, label, category. summary and timeframe for the worksheet
      * with the specified id. The course and the summary are returned as their ids. The timeframe
      * is returned as its start and end.
    </dbh:doc>
    <dbh:body>
      final String WKS = "wks";
      final String REF_CRS_WKS = "ref_crs_wks";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.FROM_DOC, REF_CRS_WKS) AS column(DbColumn.COURSE_ID)
        column(DbColumn.CLASS, CRS) AS column(DbColumn.CLASS_ID)
        column(DbColumn.LABEL, REF_CRS_WKS)
        column(DbColumn.ID, WKS)
        column(DbColumn.CATEGORY, WKS)
        column(DbColumn.TIMEFRAME_START, WKS)
        column(DbColumn.TIMEFRAME_END, WKS)
        column(DbColumn.SUMMARY, WKS) 
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS),
        table(DbTable.LATEST_DOC[DocType.WORKSHEET], WKS)
        table(DbTable.LATEST_DOC[DocType.COURSE], CRS)
        WHERE
        column(DbColumn.TO_DOC, REF_CRS_WKS) = value(worksheetId)
        AND
        column(DbColumn.ID, WKS) = value(worksheetId)
        AND
        column(DbColumn.FROM_DOC, REF_CRS_WKS) = column(DbColumn.ID, CRS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryWorksheetDataByProblemRef">
    <dbh:params>
      <dbh:param type="int" name="refId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the (latest) course, label, category, summary, and timeframe for the worksheet
      * which is the origin of the specified worksheet-problem reference. The course and the
      * summary are returned as their ids. The timeframe is returned as its start and end.
    </dbh:doc>
    <dbh:body>
      final String WKS = "wks";
      final String REF_CRS_WKS = "ref_crs_wks";
      final String REF_WKS_PRB = "ref_wks_prb";
      final String CRS = "crs";
      <dbh:sqlComposer>
        <!-- TODO: Remove superflous(?) query of course table ("crs")  -->
        SELECT
        column(DbColumn.FROM_DOC, REF_CRS_WKS) AS column(DbColumn.COURSE_ID)
        column(DbColumn.LABEL, REF_CRS_WKS)
        column(DbColumn.ID, WKS)
        column(DbColumn.CATEGORY, WKS)
        column(DbColumn.TIMEFRAME_START, WKS)
        column(DbColumn.TIMEFRAME_END, WKS)
        column(DbColumn.SUMMARY, WKS) 
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF_WKS_PRB)
        table(DbTable.LATEST_DOC[DocType.WORKSHEET], WKS)
        table(DbTable.LATEST_DOC[DocType.COURSE], CRS)
        WHERE
        column(DbColumn.ID, REF_WKS_PRB) = value(refId)
        AND
        column(DbColumn.FROM_DOC, REF_WKS_PRB) = column(DbColumn.TO_DOC, REF_CRS_WKS)
        AND
        column(DbColumn.ID, WKS) = column(DbColumn.FROM_DOC, REF_WKS_PRB)
        AND
        column(DbColumn.FROM_DOC, REF_CRS_WKS) = column(DbColumn.ID, CRS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- UNUSED, probably not needed: -->
  <dbh:method name="querySelftestData">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the (latest) course, label, category and summary of the selftest worksheet with
      * the specified id and its state with respect to the specified user.
    </dbh:doc>
    <dbh:body>
      final String REF_CRS_WKS = "ref_crs_wks";
      final String WKS = "wks";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.FROM_DOC, REF_CRS_WKS) AS column(DbColumn.COURSE_ID)
        column(DbColumn.LABEL, REF_CRS_WKS)
        column(DbColumn.CATEGORY, WKS)
        column(DbColumn.SUMMARY, WKS)
        column(DbColumn.STATE, ANN)
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF_CRS_WKS)
        table(DbTable.DOC[DocType.WORKSHEET]) AS table(WKS)
        table(DbTable.ANNS_USER_WORKSHEET) AS table(ANN)
        WHERE
        column(DbColumn.TO_DOC, REF_CRS_WKS) = value(worksheetId)
        AND
        column(DbColumn.ID, WKS) = value(worksheetId)
        AND
        column(DbColumn.DOC, ANN) = value(worksheetId)
        AND
        column(DbColumn.USER, ANN) = value(userId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- UNUSED, probably not needed: -->
  <dbh:method name="querySelftestDataByProblemRef">
    <dbh:params>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the (latest) course, label, category and summary of the selftest worksheet which
      * is the origin of the specified worksheet-problem reference and state with respect to
      * the specified user.
    </dbh:doc>
    <dbh:body>
      final String REF_CRS_WKS = "ref_crs_wks";
      final String REF_WKS_PRB = "ref_wks_prb";
      final String WKS = "wks";
      final String ANN = "ann";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.FROM_DOC, REF_CRS_WKS) AS column(DbColumn.COURSE_ID)
        column(DbColumn.LABEL, REF_CRS_WKS)
        column(DbColumn.ID, WKS)
        column(DbColumn.CATEGORY, WKS)
        column(DbColumn.SUMMARY, WKS)
        column(DbColumn.STATE, ANN)
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET], REF_CRS_WKS)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM], REF_WKS_PRB)
        table(DbTable.DOC[DocType.WORKSHEET], WKS)
        table(DbTable.ANNS_USER_WORKSHEET, ANN)
        WHERE
        column(DbColumn.ID, REF_WKS_PRB) = value(refId)
        AND
        column(DbColumn.TO_DOC, REF_CRS_WKS) = column(DbColumn.FROM_DOC, REF_WKS_PRB)
        AND
        column(DbColumn.ID, WKS) = column(DbColumn.FROM_DOC, REF_WKS_PRB)
        AND
        column(DbColumn.USER, ANN) = value(userId)
        AND
        column(DbColumn.DOC, ANN) = column(DbColumn.ID, WKS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryCourseSectionData">
    <dbh:params>
      <dbh:param type="int" name="courseSectionId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the (latest) course, label, and summary for the course section with the specified
      * id. The course and the summary are returned as their ids.
    </dbh:doc>
    <dbh:body>
      final String CSC = "csc";
      final String REF_CRS_CSC = "ref_crs_csc";
      final String CRS = "crs";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.FROM_DOC, REF_CRS_CSC) AS column(DbColumn.COURSE_ID)
        column(DbColumn.LABEL, REF_CRS_CSC)
        column(DbColumn.SUMMARY, CSC) 
        FROM
        table(DbTable.REF[DocType.COURSE][DocType.COURSE_SECTION], REF_CRS_CSC),
        table(DbTable.LATEST_DOC[DocType.COURSE_SECTION], CSC)
        table(DbTable.LATEST_DOC[DocType.COURSE], CRS)
        WHERE
        column(DbColumn.TO_DOC, REF_CRS_CSC) = value(courseSectionId)
        AND
        column(DbColumn.ID, CSC) = value(courseSectionId)
        AND
        column(DbColumn.FROM_DOC, REF_CRS_CSC) = column(DbColumn.ID, CRS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getWorksheetState" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the state of the specified worksheet with respect to the specified user, or
      * {@link WorksheetState#UNDEFINED WorksheetState.UNDEFINED} if no state has been stored
      * yet.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.STATE)
        FROM
        table(DbTable.ANNS_USER_WORKSHEET)
        WHERE
        column(DbColumn.DOC) = value(worksheetId)
        AND
        column(DbColumn.USER) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      int state =
        (resultSet.next() ? resultSet.getInt(DbColumn.STATE) : WorksheetState.UNDEFINED);
      <dbh:log>"Done. state = " + state</dbh:log>
      return state;
    </dbh:body>
  </dbh:method>

  <dbh:method name="queryReceiptData">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="refId"/>
      <dbh:param type="int" name="courseId"/>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="problemId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
    </dbh:doc>
    <dbh:body>
      final String USR = "usr";
      final String CRS = "crs";
      final String WKS = "wks";
      final String PRB = "prb";
      final String REF_CRS_WKS = "ref_crs_wks";
      final String REF_WKS_G_PRB = "ref_wks_g_prb";
      <dbh:sqlComposer>
        <!-- TODO: Remove superflous(?) query of course table ("crs")  -->
        SELECT
        column(DbColumn.FIRST_NAME, USR) AS column(DbColumn.USER_FIRST_NAME)
        column(DbColumn.SURNAME, USR) AS column(DbColumn.USER_SURNAME)
        column(DbColumn.EMAIL, USR) AS column(DbColumn.USER_EMAIL)
        column(DbColumn.NAME, CRS) AS column(DbColumn.COURSE_NAME)
        column(DbColumn.NAME, WKS) AS column(DbColumn.WORKSHEET_NAME)
        column(DbColumn.CATEGORY, WKS) AS column(DbColumn.WORKSHEET_CATEGORY_ID)
        column(DbColumn.LABEL, REF_CRS_WKS) AS column(DbColumn.WORKSHEET_LABEL)
        column(DbColumn.NAME, PRB) AS column(DbColumn.PROBLEM_NAME)
        column(DbColumn.LABEL, REF_WKS_G_PRB) AS column(DbColumn.PROBLEM_LABEL)
        FROM
        table(DbTable.USERS) AS table(USR)
        table(DbTable.DOC[DocType.COURSE]) AS table(CRS)
        table(DbTable.DOC[DocType.WORKSHEET]) AS table(WKS)
        table(DbTable.DOC[DocType.PROBLEM]) AS table(PRB)
        table(DbTable.REF[DocType.COURSE][DocType.WORKSHEET]) AS table(REF_CRS_WKS)
        table(DbTable.REF[DocType.WORKSHEET][DocType.GENERIC_PROBLEM]) AS table(REF_WKS_G_PRB)
        WHERE
        column(DbColumn.ID, USR) = value(userId)
        AND
        column(DbColumn.ID, CRS) = value(courseId)
        AND
        column(DbColumn.ID, WKS) = value(worksheetId)
        AND
        column(DbColumn.ID, PRB) = value(problemId)
        AND
        column(DbColumn.ID, REF_WKS_G_PRB) = value(refId)
        AND
        column(DbColumn.TO_DOC, REF_CRS_WKS) = value(worksheetId)
        AND
        column(DbColumn.FROM_DOC, REF_CRS_WKS) = value(courseId)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="storeWorksheetState" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="annType"/>
      <dbh:param type="int" name="state"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Stores the specified state for the specified worksheet/user pair.
    </dbh:doc>
    <dbh:body>
      if ( !WorksheetState.exists(state) )
       throw new SQLException("Unknown worksheet state: " + state);
      <dbh:sqlComposer>
        INSERT INTO
        table(DbTable.ANNS_USER_WORKSHEET)
        { column(DbColumn.DOC) column(DbColumn.USER) column(DbColumn.ANN_TYPE) column(DbColumn.STATE) }
        VALUES
        { value(worksheetId) value(userId) value(annType) value(state) }
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="updateWorksheetState" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="worksheetId"/>
      <dbh:param type="int" name="userId"/>
      <dbh:param type="int" name="state"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException" doc="if something goes wrong."/>
    </dbh:throws>
    <dbh:doc>
      * Changes the state for the specified worksheet/user pair.
    </dbh:doc>
    <dbh:body>
      if ( !WorksheetState.exists(state) )
       throw new SQLException("Unknown worksheet state: " + state);
      <dbh:sqlComposer>
        UPDATE
        table(DbTable.ANNS_USER_WORKSHEET)
        SET
        column(DbColumn.STATE) = value(state)
        WHERE
        column(DbColumn.DOC) = value(worksheetId)
        AND
        column(DbColumn.USER) = value(userId)
      </dbh:sqlComposer>
      <dbh:executeUpdate/>
    </dbh:body>
  </dbh:method>

  <dbh:method name="getSubSectionForSemesterSyncId" returnType="int">
    <dbh:params>
      <dbh:param type="String" name="semesterSyncId"/>
      <dbh:param type="String" name="sectionPureName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id of the section with the specified pure name and which is contained
      * in the same section as the semester with the specified sync id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(DbTable.SECTIONS)
        WHERE
        column(DbColumn.PURE_NAME) = value(sectionPureName)
        AND
        column(DbColumn.CONTAINED_IN) =
          {
            SELECT
            column(DbColumn.CONTAINED_IN)
            FROM
            table(DbTable.SEMESTERS)
            WHERE
            column(DbColumn.SYNC_ID) = value(semesterSyncId)
          }
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( ! resultSet.next() )
        throw new SQLException
          ("Can not find section for semester sync id \"" + semesterSyncId + "\" " +
           "and pure name \"" + sectionPureName + "\"");
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Getting "sync_home" section id for user id.                                  -->
  <!-- ================================================================================ -->

  <dbh:method name="getSyncHome" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="userId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the "sync_home" section id for the user with the specified id
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.SYNC_HOME)
        FROM
        table(DbTable.USERS)
        WHERE
        column(DbColumn.ID) = value(userId)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("No sync home section found userId: " + userId);
      int id = resultSet.getInt(DbColumn.SYNC_HOME);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Getting id's for paths                                                       -->
  <!-- ================================================================================ -->

  <dbh:method name="getSectionIdForPath" returnType="int" target="PostgreSQLDbHelper">
    <dbh:params>
      <dbh:param type="String" name="path"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id for the section with the specified path. If the section does not
      * exist, returns -1.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT funcCall("section_id_for_path", 0, path) AS column(DbColumn.ID)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("Failed to determione id for path: " + path);
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getIdForPath" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="path"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id for the document with the specified type and path.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      boolean onlyLatest = !DocType.isGeneric(type);
      ResultSet resultSet =
        this.queryDataByPath(type, path, new String[] {DbColumn.ID}, onlyLatest);
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not resolve path \"" + path + "\" for doc type " + type + "." +
           " (Result set empty)");
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <dbh:method name="getPseudoDocIdForPath" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="type"/>
      <dbh:param type="String" name="path"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id for the pseudo-document with the specified type and path.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      ResultSet resultSet =
        this.queryPseudoDocDataByPath(type, path, new String[] {DbColumn.ID});
      if ( !resultSet.next() )
        throw new SQLException
          ("Can not resolve path \"" + path + "\" for pseudo-doc type " + type + "." +
           " (Result set empty)");
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Getting Paths for id's                                                       -->
  <!-- ================================================================================ -->

  <dbh:method name="getSectionPathForId" returnType="String">
    <dbh:params>
      <dbh:param type="int" name="id"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the path for the section with the specified id.
    </dbh:doc>
    <dbh:body>
      <dbh:sqlComposer>
        SELECT funcCall("path_for_section_id", id) AS column(DbColumn.PATH);
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("No path found for section id: " + id);
      String path = resultSet.getString(DbColumn.PATH);
      <dbh:log>"Done. path = " + path</dbh:log>
      return path;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Resolving qualified names                                                    -->
  <!-- ================================================================================ -->

  <dbh:method name="getIdForQualifiedName" returnType="int">
    <dbh:params>
      <dbh:param type="int" name="docType"/>
      <dbh:param type="String" name="qualifiedName"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id of the document with the specified type and qualified name. Unless
      * the document type is generic, only latest versions are considered.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      if ( ! DocType.hasQualifiedName[docType] )
        throw new IllegalArgumentException("Document type has no qualified name: " + docType);
      boolean onlyLatest = !DocType.isGeneric[docType];
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(this.getTableName(docType, onlyLatest))
        WHERE
        column(DbColumn.QUALIFIED_NAME) = value(qualifiedName)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException("Result set empty");
      int id = resultSet.getInt(DbColumn.ID);
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Resolving OIDs (Postgres only)                                               -->
  <!-- ================================================================================ -->

  <dbh:method name="getIdForOid" returnType="int" access="protected">
    <dbh:params>
      <dbh:param type="long" name="oid"/>
      <dbh:param type="String" name="table"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns the id for a given oid.
      * @param oid the oid.
      * @param table the table where to search for the id.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.ID)
        FROM
        table(table)
        WHERE
        column("oid") = value(oid)
      </dbh:sqlComposer>
      String query = this.sqlComposer.getCode();
      <dbh:log>"query = " + query</dbh:log>
      ResultSet resultSet = this.connection.createStatement().executeQuery(query);
      if ( !resultSet.next() )
        throw new SQLException
          ("Failed to find id for oid: oid = " + oid + ", table = " + table +
           ": Result set empty");
      int id = resultSet.getInt(1); 
      <dbh:log>"Done. id = " + id</dbh:log>
      return id;
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Querying refs with same lids                                                 -->
  <!-- ================================================================================ -->

  <dbh:method name="queryRefsWithSameLids" access="protected">
    <dbh:params>
      <dbh:param type="int" name="fromDocType"/>
      <dbh:param type="int" name="toDocType"/>
      <dbh:param type="int" name="newFromDocId"/>
      <dbh:param type="int" name="oldFromDocId"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Returns pairs of references originating from <h:code>newFromDocId</h:code> and
      * <h:code>oldDocId</h:code>, respectively, that have the same local id.
      * <h:code>fromDocType</h:code> and <h:code>toDocType</h:code> specify the origin resp.
      * target document type of the references. The returned result set contains the following
      * columns:
      * <h:ol>
      *   <h:li>{@link DbColumn#LID LID} (the common lid),</h:li>
      *   <h:li>{@link DbColumn#NEW_ID NEW_ID} (id of the reference originating from
      *     <h:code>newFromDocId</h:code>),</h:li>
      *   <h:li>{@link DbColumn#OLD_ID OLD_ID} (id of the reference originating from
      *     <h:code>oldFromDocId</h:code>),</h:li>
      *   <h:li>{@link DbColumn#NEW_REF_TYPE NEW_REF_TYPE} (type of the reference originating
      *      from <h:code>newFromDocId</h:code>),</h:li>
      *   <h:li>{@link DbColumn#OLD_REF_TYPE OLD_REF_TYPE} (type of the reference originating
      *      from <h:code>oldFromDocId</h:code>).</h:li>
      * </h:ol>
    </dbh:doc>
    <dbh:body>
      final String OLD_REFS = "r1";
      final String NEW_REFS = "r2";
      <dbh:sqlComposer>
        SELECT
        column(DbColumn.LID, NEW_REFS)
        column(DbColumn.ID, NEW_REFS) AS column(DbColumn.NEW_ID)
        column(DbColumn.ID, OLD_REFS) AS column(DbColumn.OLD_ID)
        column(DbColumn.REF_TYPE, NEW_REFS) AS column(DbColumn.NEW_REF_TYPE)
        column(DbColumn.REF_TYPE, OLD_REFS) AS column(DbColumn.OLD_REF_TYPE)
        FROM
        table(DbTable.REF[fromDocType][toDocType]) AS table(NEW_REFS)
        table(DbTable.REF[fromDocType][toDocType]) AS table(OLD_REFS)
        WHERE
        column(DbColumn.FROM_DOC, NEW_REFS) = value(newFromDocId)
        AND
        column(DbColumn.FROM_DOC, OLD_REFS) = value(oldFromDocId)
        AND
        column(DbColumn.LID, NEW_REFS) = column(DbColumn.LID, OLD_REFS)
      </dbh:sqlComposer>
      <dbh:returnResultSet/>
    </dbh:body>
  </dbh:method>

  <!-- ================================================================================ -->
  <!-- h1: Transactions                                                                 -->
  <!-- ================================================================================ -->

  <dbh:method name="beginTransaction" returnType="void">
    <dbh:params>
      <dbh:param type="Object" name="locker"/>
      <dbh:param type="boolean" name="wantsToWrite"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IllegalStateException"/>
    </dbh:throws>
    <dbh:doc>
      * Starts a transaction.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      if ( this.locker != null )
        throw new IllegalStateException
          (this.getIdentification() + ": " + METHOD_NAME +
           ": Locked by another object: " + this.locker);
      this.oldIsolationLevel = this.connection.getTransactionIsolation(); 
      this.oldAutoCommitState = this.connection.getAutoCommit(); 
      if ( wantsToWrite )
        this.connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
      this.connection.setAutoCommit(false);                 
      this.locker = locker;
      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="endTransaction" returnType="void">
    <dbh:params>
      <dbh:param type="Object" name="locker"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IllegalStateException"/>
    </dbh:throws>
    <dbh:doc>
      * Ends a transaction.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      if ( this.locker != locker )
        throw new IllegalStateException
          (this.getIdentification() + ": " + METHOD_NAME +
           ": Locked by another object: this.locker = " + this.locker +
           ", locker = " + locker);
      this.connection.commit(); 
      this.connection.setTransactionIsolation(this.oldIsolationLevel);
      this.connection.setAutoCommit(this.oldAutoCommitState); 
      this.locker = null; 
      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="abortTransaction" returnType="void">
    <dbh:params>
      <dbh:param type="Object" name="locker"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
      <dbh:throwable name="IllegalStateException"/>
    </dbh:throws>
    <dbh:doc>
      * Aborts a transaction.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>

      if ( this.locker != locker )
        throw new IllegalStateException
          (this.getIdentification() + ": " + METHOD_NAME +
           ": Locked by another object: this.locker = " + this.locker +
           ", locker = " + locker);

      // Reset isolation level:
      try
        {
          this.connection.setTransactionIsolation(this.oldIsolationLevel);      
        }
      catch (SQLException exception)
        {
          this.logWarn("Transaction already aborted"); 
        }

      // Rollback:
      this.connection.rollback(); 

      // Reset autocommit:
      this.connection.setAutoCommit(this.oldAutoCommitState);

      // Reset locker:
      this.locker = null; 

      <dbh:log>"Done"</dbh:log>
    </dbh:body>
  </dbh:method>

  <dbh:method name="hasTransactionLocked" returnType="boolean">
    <dbh:params>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Checks if this instance has been locked to handle exactly one transaction.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      boolean hasTransactionLocked =
        ( this.locker != null );
      <dbh:log>"Done. hasTransactionLocked = " + hasTransactionLocked</dbh:log>
      return hasTransactionLocked;
    </dbh:body>
  </dbh:method>

  <dbh:method name="hasTransactionLocked" returnType="boolean">
    <dbh:params>
      <dbh:param type="Object" name="locker"/>
    </dbh:params>
    <dbh:throws>
      <dbh:throwable name="SQLException"/>
    </dbh:throws>
    <dbh:doc>
      * Checks if this instance has been locked by the specified object to handle exactly
      * one transaction.
    </dbh:doc>
    <dbh:body>
      <dbh:log printParams="yes">"Started"</dbh:log>
      boolean hasTransactionLocked =
        ( this.locker == locker );
      <dbh:log>"Done. hasTransactionLocked = " + hasTransactionLocked</dbh:log>
      return hasTransactionLocked;
    </dbh:body>
  </dbh:method>

</dbh:DbHelper>
