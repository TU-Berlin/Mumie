/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2010 Technische Universitaet Berlin
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package net.mumie.coursecreator.xml;

import javax.swing.JOptionPane;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.OutputKeys;

import net.mumie.coursecreator.CCController;

import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang.StringUtils;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;



/***
 * GraphXMLizer.java
 *
 * Created: Wed Jun  1 13:22:47 2005
 **/
/**
 * Provides basic functionality to convert a DOM representation of a course
 * graph to an XML String. 
 *
 * @author <a href="mailto:sinha@math.tu-berlin.de">Uwe Sinha</a>
 * @author <a href="mailto:doehrint@in.tum.de">Thomas D&ouml;hring</a>
 * @version $Revision: 1.3 $ ($Date: 2009/03/30 12:34:24 $)
 */

public class GraphXMLizer {

    /**
     * Converts a DOM tree to an XML string. 
     *
     * @param document a {@link Document} or {@link DocumentFragment} to be
     * converted
     * @return the corresponding <code>String</code> representation 
     * @exception TransformerException if an error occurs
     * @exception UnsupportedEncodingException if an error occurs
     */
    public static String toXMLString(Node document) 
	throws TransformerException, UnsupportedEncodingException
    {
	return doTransform(document).toString(); 
    }    

    /**
     * Converts a DOM tree to an array of bytes which can be written to a
     * file directly. 
     *
     * @param document a {@link Document} or {@link DocumentFragment} to be
     * converted
     * @return the corresponding byte array representation 
     * @exception TransformerException if an error occurs
     * @exception UnsupportedEncodingException if an error occurs
     */
    public static byte[] toByteArray(Node document) 
	throws TransformerException, UnsupportedEncodingException
    {
	return doTransform(document).toByteArray();
    }    

    /**
     * Describe <code>doTransform</code> method here.
     *
     * @param document a <code>Node</code> value
     * @return a <code>ByteArrayOutputStream</code> value
     * @exception TransformerException if an error occurs
     * @exception UnsupportedEncodingException if an error occurs
     */
    private static ByteArrayOutputStream doTransform(Node document) 
	throws TransformerException, UnsupportedEncodingException 
    {
 	try {

	    // Use a Transformer for output
	    TransformerFactory tFactory = 
		TransformerFactory.newInstance();
	    Transformer transformer = tFactory.newTransformer();
	    transformer.setOutputProperty(OutputKeys.INDENT, "yes"); 
	    transformer.setOutputProperty(OutputKeys.ENCODING, "US-ASCII"); 

	    DOMSource source = new DOMSource(document);

	    ByteArrayOutputStream baos = new ByteArrayOutputStream();
  	    OutputStreamWriter out = new OutputStreamWriter(baos, "ASCII"); 
   	    StreamResult result = new StreamResult(out);
	    transformer.transform(source, result);

	    return baos;

        } catch (TransformerException te) {
	    // Error generated by the parser
        	CCController.dialogErrorOccured(
					"GraphXMLizer: TransformerException", 
					"GraphXMLizer: TransformerException: " + te, 
					JOptionPane.ERROR_MESSAGE);
        	
	    throw te; 
        }
    }

    /**
     * Describe <code>recodeUmlauts</code> method here.
     *
     * @param theText a <code>Text</code> value
     * @deprecated method considered harmful as its result confuses the transformer
     */
    public static void recodeUmlauts(Text theText) {

	
	String txt = theText.getData(); 
	// FIXME(4): one might want to allow HTML entities to appear in the
	//           Text node someday. These must be weeded out beforehand. 
	String xmlString = StringEscapeUtils.escapeXml(txt);
// 	xmlString = StringUtils.replace(xmlString, "&amp;#", "&#");

	try {
	    theText.setData(xmlString); 
	} catch (RuntimeException re) {
    	CCController.dialogErrorOccured(
				"GraphXMLizer: RuntimeException", 
				"GraphXMLizer: RuntimeException: " + re, 
				JOptionPane.ERROR_MESSAGE);
	    
	    // nothing -- leave theText as-is
	} // end of try-catch
    }

    public static void recodeUmlauts(Node node) { 
	NodeList nl = node.getChildNodes();
	
	if (node instanceof Text) {
	    throw new IllegalArgumentException
		("Whoops! using the non-Text variant for a Text node!"); 
	} // end of if ()
	
	// If 'nl' is empty, the body of the following for loop (i.e. the
	// recursion) will simply be skipped. in that case we return with
	// 'node' unchanged. 
	for (int i = 0; i < nl.getLength() ; i++) {
	    Node curr = nl.item(i);
	    if (curr.getNodeType() == Node.TEXT_NODE) {
		recodeUmlauts((Text)curr); 
	    } // end of if (curr.getNodeType() == Node.TEXT_NODE)
	    else {
		recodeUmlauts(curr); 		
	    } // end of if (curr.getNodeType() == Node.TEXT_NODE) else

	} // end of for (int i = 0; i < nl.getLength() ; i++)
    }
    
    static final String[] htmlEntities = {"&auml;","&ouml;", "&uuml;", "&szlig;", 
					  "&Auml;","&Ouml;", "&Uuml;"};
    static final int[] codes = {228, 246, 252, 223, 196, 214, 220}; 


}// GraphXMLizer
